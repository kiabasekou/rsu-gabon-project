"""
üá¨üá¶ RSU Gabon - Moteur Scoring Vuln√©rabilit√©
Version simplifi√©e pour d√©ploiement rapide
"""

import logging
from typing import Dict, List

logger = logging.getLogger(__name__)

class VulnerabilityCalculator:
    """Calculateur vuln√©rabilit√© contextualis√© Gabon"""
    
    # Seuils √©conomiques Gabon (FCFA)
    POVERTY_THRESHOLDS = {
        'EXTREME': 75_000,
        'MODERATE': 150_000,
        'MIDDLE_CLASS': 500_000,
    }
    
    # Pond√©rations dimensions
    WEIGHTS = {
        'economic': 0.30,
        'social': 0.25,
        'demographic': 0.20,
        'geographic': 0.15,
        'resilience': 0.10,
    }
    
    def calculate_vulnerability_score(self, person_data: Dict) -> Dict:
        """Calcul score vuln√©rabilit√© complet"""
        try:
            # Calcul par dimension
            scores = {
                'economic': self._calc_economic(person_data),
                'social': self._calc_social(person_data),
                'demographic': self._calc_demographic(person_data),
                'geographic': self._calc_geographic(person_data),
                'resilience': self._calc_resilience(person_data),
            }
            
            # Score global pond√©r√©
            global_score = sum(
                scores[dim] * self.WEIGHTS[dim] 
                for dim in scores
            )
            
            return {
                'global_score': round(global_score, 2),
                'dimension_scores': scores,
                'vulnerability_level': self._get_level(global_score),
                'recommendations': self._get_recommendations(scores),
                'program_eligibility': self._calc_eligibility(scores, global_score),
                'geographic_priority': 'MEDIUM_PRIORITY',
                'confidence_score': 85.0
            }
            
        except Exception as e:
            logger.error(f"Erreur calcul vuln√©rabilit√©: {e}")
            return self._default_assessment()
    
    def _calc_economic(self, data: Dict) -> float:
        """Dimension √©conomique (30%)"""
        score = 0.0
        
        income = data.get('monthly_income', 0)
        if income <= self.POVERTY_THRESHOLDS['EXTREME']:
            score += 50
        elif income <= self.POVERTY_THRESHOLDS['MODERATE']:
            score += 30
        elif income <= self.POVERTY_THRESHOLDS['MIDDLE_CLASS']:
            score += 15
        
        occupation = data.get('occupation', '').upper()
        if occupation in ['UNEMPLOYED', 'CHOMEUR']:
            score += 25
        elif occupation in ['INFORMAL', 'FARMER']:
            score += 15
        
        housing = data.get('housing_type', '').upper()
        if housing in ['PRECARIOUS', 'CASE_TRADITIONNELLE']:
            score += 15
        
        if not data.get('has_bank_account', False):
            score += 10
        
        return min(score, 100.0)
    
    def _calc_social(self, data: Dict) -> float:
        """Dimension sociale (25%)"""
        score = 0.0
        
        education = data.get('education_level', '').upper()
        if education in ['NONE', 'AUCUN']:
            score += 35
        elif education in ['PRIMARY', 'PRIMAIRE']:
            score += 20
        
        if not data.get('has_health_insurance', False):
            score += 20
        
        distance_health = data.get('distance_health_center_km', 50)
        if distance_health > 30:
            score += 15
        elif distance_health > 15:
            score += 8
        
        if data.get('social_support_network', '').upper() in ['WEAK', 'NONE']:
            score += 15
        
        if data.get('has_disability', False):
            score += 10
        
        return min(score, 100.0)
    
    def _calc_demographic(self, data: Dict) -> float:
        """Dimension d√©mographique (20%)"""
        score = 0.0
        
        age = data.get('age', 30)
        if age < 5 or age > 65:
            score += 25
        elif age < 18:
            score += 15
        
        if (data.get('gender') == 'F' and 
            data.get('is_household_head', False)):
            score += 20
        
        household_size = data.get('household_size', 4)
        if household_size > 8:
            score += 15
        elif household_size > 5:
            score += 8
        
        if data.get('marital_status', '').upper() in ['WIDOW', 'DIVORCED']:
            score += 12
        
        if data.get('is_pregnant', False) or data.get('is_breastfeeding', False):
            score += 10
        
        return min(score, 100.0)
    
    def _calc_geographic(self, data: Dict) -> float:
        """Dimension g√©ographique (15%)"""
        score = 0.0
        
        province = data.get('province', 'ESTUAIRE').upper()
        province_scores = {
            'OGOOUE_IVINDO': 45,
            'NYANGA': 40,
            'MOYEN_OGOOUE': 35,
            'OGOOUE_LOLO': 35,
            'NGOUNIER': 30,
            'WOLEU_NTEM': 30,
            'HAUT_OGOOUE': 25,
            'OGOOUE_MARITIME': 20,
            'ESTUAIRE': 10,
        }
        score += province_scores.get(province, 25)
        
        zone_type = data.get('zone_type', 'RURAL').upper()
        if 'REMOTE' in zone_type:
            score += 25
        elif 'RURAL' in zone_type:
            score += 15
        
        road_access = data.get('road_access_type', 'DIRT').upper()
        if road_access in ['FOOTPATH', 'NONE']:
            score += 15
        elif road_access == 'DIRT':
            score += 10
        
        return min(score, 100.0)
    
    def _calc_resilience(self, data: Dict) -> float:
        """Dimension r√©silience (10%)"""
        score = 0.0
        
        if data.get('climate_shock_exposure', '').upper() == 'HIGH':
            score += 25
        
        if not data.get('has_savings', False):
            score += 20
        
        if not data.get('diversified_income_sources', False):
            score += 15
        
        recovery_time = data.get('recovery_time_months', 12)
        if recovery_time > 24:
            score += 20
        elif recovery_time > 12:
            score += 10
        
        return min(score, 100.0)
    
    def _get_level(self, score: float) -> str:
        """D√©termine niveau vuln√©rabilit√©"""
        if score >= 75:
            return 'CRITICAL'
        elif score >= 50:
            return 'HIGH'
        elif score >= 25:
            return 'MODERATE'
        else:
            return 'LOW'
    
    def _get_recommendations(self, scores: Dict) -> List[str]:
        """G√©n√®re recommandations selon scores"""
        recommendations = []
        
        if scores['economic'] >= 40:
            recommendations.append("Transferts mon√©taires prioritaires")
        if scores['social'] >= 35:
            recommendations.append("Acc√®s soins sant√© am√©lior√©")
        if scores['demographic'] >= 30:
            recommendations.append("Appui familles vuln√©rables")
        if scores['geographic'] >= 35:
            recommendations.append("Programmes d√©veloppement rural")
        if scores['resilience'] >= 25:
            recommendations.append("Renforcement m√©canismes adaptation")
        
        return recommendations[:3]  # Top 3
    
    def _calc_eligibility(self, scores: Dict, global_score: float) -> Dict:
        """Calcul √©ligibilit√© programmes sociaux"""
        eligibility = {}
        
        if scores['economic'] >= 35:
            eligibility['transferts_monetaires'] = min(scores['economic'] * 1.2, 100)
        
        if scores['social'] >= 30:
            eligibility['sante_gratuite'] = min(scores['social'] * 1.1, 100)
        
        if scores['geographic'] >= 30:
            eligibility['developpement_rural'] = min(scores['geographic'] * 1.15, 100)
        
        if global_score >= 70:
            eligibility['aide_urgence'] = min(global_score * 1.1, 100)
        
        return eligibility
    
    def _default_assessment(self) -> Dict:
        """Assessment par d√©faut en cas d'erreur"""
        return {
            'global_score': 50.0,
            'dimension_scores': {dim: 50.0 for dim in self.WEIGHTS},
            'vulnerability_level': 'MODERATE',
            'recommendations': ["√âvaluation d√©taill√©e requise"],
            'program_eligibility': {},
            'geographic_priority': 'MEDIUM_PRIORITY',
            'confidence_score': 50.0
        }
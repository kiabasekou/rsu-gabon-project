# apps/services_app/services/vulnerability_service.py
"""
üá¨üá¶ RSU GABON - Service Vuln√©rabilit√©
Calcul intelligent de vuln√©rabilit√© multidimensionnelle
Standards: Top 1% International
"""

import logging
from typing import Dict, List
from decimal import Decimal
from django.db import transaction
from django.utils import timezone
from django.db.models import Count, Avg

from apps.identity_app.models import PersonIdentity
from ..models import VulnerabilityAssessment
from .base_service import BaseService

logger = logging.getLogger(__name__)


class VulnerabilityService(BaseService):
    """Service de calcul vuln√©rabilit√© contextualis√© Gabon"""
    
    def calculate_and_save_assessment(
        self, 
        person_id: int, 
        assessed_by=None, 
        force_recalculate: bool = False
    ) -> VulnerabilityAssessment:
        """
        Calcule et sauvegarde √©valuation vuln√©rabilit√©
        
        Args:
            person_id: ID personne
            assessed_by: Utilisateur √©valuateur
            force_recalculate: Forcer recalcul
            
        Returns:
            VulnerabilityAssessment cr√©√©
        """
        try:
            person = PersonIdentity.objects.get(id=person_id)
            
            # V√©rifier √©valuation existante r√©cente
            if not force_recalculate:
                existing = VulnerabilityAssessment.objects.filter(
                    person=person
                ).order_by('-assessment_date').first()
                
                if existing:
                    days_since = (timezone.now() - existing.assessment_date).days
                    if days_since < 180:  # 6 mois
                        return existing
            
            # Calcul nouvelle √©valuation
            assessment_data = self._calculate_vulnerability_assessment(person)
            
            # Sauvegarde
            with transaction.atomic():
                assessment = VulnerabilityAssessment.objects.create(
                    person=person,
                    vulnerability_score=assessment_data['vulnerability_score'],
                    risk_level=assessment_data['risk_level'],
                    household_composition_score=assessment_data['household_composition_score'],
                    economic_vulnerability_score=assessment_data['economic_vulnerability_score'],
                    social_vulnerability_score=assessment_data['social_vulnerability_score'],
                    vulnerability_factors=assessment_data['vulnerability_factors'],
                    risk_factors=assessment_data['risk_factors'],
                    protective_factors=assessment_data['protective_factors'],
                    recommendations=assessment_data['recommendations'],
                    priority_interventions=assessment_data['priority_interventions'],
                    assessment_notes=assessment_data.get('assessment_notes', '')
                )
                
                # Log op√©ration
                self.log_operation(
                    'assessment_calculated',
                    {
                        'person_id': person_id,
                        'vulnerability_score': float(assessment.vulnerability_score),
                        'risk_level': assessment.risk_level
                    }
                )
                
                return assessment
                
        except PersonIdentity.DoesNotExist:
            logger.error(f"PersonIdentity {person_id} not found")
            raise ValueError(f"Personne {person_id} introuvable")
        except Exception as e:
            logger.error(f"Erreur calcul assessment pour {person_id}: {str(e)}")
            raise

    def _calculate_vulnerability_assessment(self, person: PersonIdentity) -> Dict:
        """
        Calcule √©valuation vuln√©rabilit√© compl√®te
        
        Returns:
            Dict avec champs align√©s sur mod√®le VulnerabilityAssessment
        """
        # Calcul scores par dimension
        economic_score = self._calculate_economic_vulnerability(person)
        social_score = self._calculate_social_vulnerability(person)
        geographic_score = self._calculate_geographic_vulnerability(person)
        health_score = self._calculate_health_vulnerability(person)
        education_score = self._calculate_education_vulnerability(person)
        
        # Score global pond√©r√©
        vulnerability_score = (
            economic_score * 0.30 +
            social_score * 0.25 +
            geographic_score * 0.20 +
            health_score * 0.15 +
            education_score * 0.10
        )
        
        # Niveau de risque
        if vulnerability_score >= 80:
            risk_level = 'CRITICAL'
        elif vulnerability_score >= 60:
            risk_level = 'HIGH'
        elif vulnerability_score >= 40:
            risk_level = 'MODERATE'
        else:
            risk_level = 'LOW'
        
        # Facteurs de vuln√©rabilit√©
        vulnerability_factors = []
        if economic_score >= 70:
            vulnerability_factors.append('ECONOMIC_VULNERABILITY')
        if social_score >= 70:
            vulnerability_factors.append('SOCIAL_ISOLATION')
        if geographic_score >= 70:
            vulnerability_factors.append('GEOGRAPHIC_ISOLATION')
        
        # Facteurs de risque
        risk_factors = []
        household = getattr(person, 'headed_household', None)
        if household:
            if household.total_monthly_income and household.total_monthly_income < 50000:
                risk_factors.append('EXTREME_POVERTY')
            if household.has_disabled_members:
                risk_factors.append('DISABLED_MEMBERS')
            if household.has_children_under_5:
                risk_factors.append('YOUNG_CHILDREN')
        
        if person.has_disability:
            risk_factors.append('PERSONAL_DISABILITY')
        
        # Facteurs protecteurs
        protective_factors = []
        if person.education_level in ['UNIVERSITY', 'POSTGRADUATE']:
            protective_factors.append('HIGH_EDUCATION')
        if household and household.has_bank_account:
            protective_factors.append('FINANCIAL_INCLUSION')
        
        # Recommandations
        recommendations = []
        if economic_score >= 70:
            recommendations.append('CASH_TRANSFER_PROGRAM')
        if health_score >= 70:
            recommendations.append('HEALTH_INSURANCE')
        if education_score >= 70:
            recommendations.append('EDUCATION_SUPPORT')
        
        # Interventions prioritaires
        priority_interventions = []
        if risk_level in ['CRITICAL', 'HIGH']:
            priority_interventions.append({
                'type': 'IMMEDIATE_ASSISTANCE',
                'urgency': 'HIGH',
                'estimated_cost': 150000
            })
        
        return {
            'vulnerability_score': Decimal(str(round(vulnerability_score, 2))),
            'risk_level': risk_level,
            'household_composition_score': Decimal(str(round(social_score, 2))),
            'economic_vulnerability_score': Decimal(str(round(economic_score, 2))),
            'social_vulnerability_score': Decimal(str(round(social_score, 2))),
            'vulnerability_factors': vulnerability_factors,
            'risk_factors': risk_factors,
            'protective_factors': protective_factors,
            'recommendations': recommendations,
            'priority_interventions': priority_interventions,
            'assessment_notes': f"Score: {vulnerability_score:.2f} - Niveau: {risk_level}"
        }

    def _calculate_economic_vulnerability(self, person: PersonIdentity) -> float:
        """Calcul vuln√©rabilit√© √©conomique (0-100)"""
        score = 0.0
        
        household = getattr(person, 'headed_household', None)
        if not household:
            return 50.0  # Score moyen si pas de donn√©es m√©nage
        
        # Revenus mensuels
        income = household.total_monthly_income or 0
        if income < 50000:  # Extr√™me pauvret√©
            score += 40
        elif income < 100000:  # Pauvret√©
            score += 30
        elif income < 300000:  # Vuln√©rable
            score += 15
        
        # Taille m√©nage vs revenus
        if household.household_size > 0:
            income_per_capita = income / household.household_size
            if income_per_capita < 20000:
                score += 20
            elif income_per_capita < 50000:
                score += 10
        
        # Acc√®s services financiers
        if not household.has_bank_account:
            score += 15
        
        # Type logement
        if household.housing_type in ['RENTED', 'INFORMAL', 'HOSTED']:
            score += 10
        
        # Acc√®s services de base
        if household.water_access in ['VENDOR', 'NONE']:
            score += 10
        if household.electricity_access == 'NONE':
            score += 5
        
        return min(100.0, score)

    def _calculate_social_vulnerability(self, person: PersonIdentity) -> float:
        """Calcul vuln√©rabilit√© sociale (0-100)"""
        score = 0.0
        
        household = getattr(person, 'headed_household', None)
        
        # Statut matrimonial
        if person.marital_status in ['SINGLE', 'DIVORCED', 'WIDOW']:
            score += 15
        
        # Chef de m√©nage vuln√©rable
        if household:
            if person.gender == 'F' and household.household_size > 3:
                score += 20  # Femme chef de famille nombreuse
            
            # Pr√©sence membres vuln√©rables
            if household.has_disabled_members:
                score += 15
            if household.has_elderly_members:
                score += 10
            if household.has_children_under_5:
                score += 10
            
            # Ratio d√©pendance √©lev√©
            dependency_ratio = household.calculate_dependency_ratio()
            if dependency_ratio > 100:
                score += 15
            elif dependency_ratio > 50:
                score += 10
        
        # Handicap personnel
        if person.has_disability:
            score += 20
        
        return min(100.0, score)

    def _calculate_geographic_vulnerability(self, person: PersonIdentity) -> float:
        """Calcul vuln√©rabilit√© g√©ographique (0-100)"""
        score = 0.0
        
        # Provinces isol√©es
        isolated_provinces = ['NYANGA', 'OGOOUE_LOLO', 'OGOOUE_IVINDO']
        if person.province in isolated_provinces:
            score += 40
        
        moderate_provinces = ['NGOUNIE', 'WOLEU_NTEM', 'HAUT_OGOOUE']
        if person.province in moderate_provinces:
            score += 25
        
        # Milieu rural (estimation par commune)
        if person.commune and 'RURAL' in person.commune.upper():
            score += 20
        
        # Absence coordonn√©es GPS
        if not person.latitude or not person.longitude:
            score += 15
        
        return min(100.0, score)

    def _calculate_health_vulnerability(self, person: PersonIdentity) -> float:
        """Calcul vuln√©rabilit√© sant√© (0-100)"""
        score = 0.0
        
        # Handicap
        if person.has_disability:
            score += 30
        
        # √Çge vuln√©rable
        age = person.age
        if age and (age < 5 or age > 65):
            score += 20
        
        household = getattr(person, 'headed_household', None)
        if household:
            # Membres vuln√©rables sant√©
            if household.has_disabled_members:
                score += 15
            if household.has_elderly_members:
                score += 10
            if household.has_pregnant_women:
                score += 15
        
        return min(100.0, score)

    def _calculate_education_vulnerability(self, person: PersonIdentity) -> float:
        """Calcul vuln√©rabilit√© √©ducation (0-100)"""
        score = 0.0
        
        education = person.education_level
        
        if education in ['NONE', 'INCOMPLETE_PRIMARY']:
            score += 40
        elif education == 'PRIMARY':
            score += 30
        elif education == 'SECONDARY':
            score += 15
        
        # √Çge vs niveau √©ducation
        age = person.age
        if age and age > 25 and education in ['NONE', 'INCOMPLETE_PRIMARY']:
            score += 20
        
        return min(100.0, score)

    def bulk_calculate_assessments(
        self, 
        person_ids: List[int],
        assessed_by=None
    ) -> Dict:
        """
        Calcul en lot d'√©valuations
        
        Returns:
            Dict: {'success': int, 'errors': int, 'details': list}
        """
        results = {'success': 0, 'errors': 0, 'details': []}
        
        try:
            for person_id in person_ids:
                try:
                    assessment = self.calculate_and_save_assessment(
                        person_id=person_id,
                        assessed_by=assessed_by,
                        force_recalculate=False
                    )
                    
                    results['success'] += 1
                    results['details'].append({
                        'person_id': person_id,
                        'status': 'success',
                        'score': float(assessment.vulnerability_score)
                    })
                    
                except Exception as e:
                    results['errors'] += 1
                    results['details'].append({
                        'person_id': person_id,
                        'status': 'error',
                        'error': str(e)
                    })
            
            return results
            
        except Exception as e:
            logger.error(f"Erreur bulk assessment: {str(e)}")
            raise

    def get_vulnerability_statistics(
        self,
        province: str = None
    ) -> Dict:
        """
        Statistiques vuln√©rabilit√©
        
        Returns:
            Dict: Statistiques compl√®tes
        """
        try:
            queryset = VulnerabilityAssessment.objects.filter(is_active=True)
            
            if province:
                queryset = queryset.filter(person__province=province)
            
            total = queryset.count()
            
            if total == 0:
                return {'total_assessments': 0, 'message': 'Aucune √©valuation'}
            
            # Distribution par niveau
            level_dist = queryset.values('risk_level').annotate(
                count=Count('id')
            )
            
            # Scores moyens
            avg_scores = queryset.aggregate(
                avg_vulnerability=Avg('vulnerability_score'),
                avg_economic=Avg('economic_vulnerability_score'),
                avg_social=Avg('social_vulnerability_score')
            )
            
            return {
                'total_assessments': total,
                'level_distribution': list(level_dist),
                'average_scores': avg_scores
            }
            
        except Exception as e:
            logger.error(f"Erreur statistiques: {str(e)}")
            raise
# ===================================================================
# RSU GABON - SERVICE VULNERABILITY SCORING IA
# Standards Top 1% - Intelligence Artificielle contextualisée
# ===================================================================

import logging
from typing import Dict, List, Optional, Tuple
from decimal import Decimal
from django.db import transaction
from django.utils import timezone
from django.db.models import Count, Avg, Q

from apps.identity_app.models import PersonIdentity
from ..models import VulnerabilityAssessment
from .base_service import BaseService

logger = logging.getLogger(__name__)


class VulnerabilityService(BaseService):
    """
    Service de calcul intelligente vulnérabilité
    Algorithmes IA contextualisés pour le Gabon
    """
    
    # Pondérations dimensions vulnérabilité (contexte Gabon)
    DIMENSION_WEIGHTS = {
        'economic': 0.30,      # Économique (revenus, emploi)
        'social': 0.25,        # Social (famille, isolation)
        'geographic': 0.20,    # Géographique (accès services)
        'health': 0.15,        # Santé (état, accès soins)
        'education': 0.10      # Éducation (niveau, accès)
    }
    
    # Seuils vulnérabilité
    VULNERABILITY_THRESHOLDS = {
        'CRITICAL': 80,
        'HIGH': 60,
        'MODERATE': 40,
        'LOW': 0
    }
    
    # Zones géographiques prioritaires Gabon
    GEOGRAPHIC_PRIORITY_MAPPING = {
        'ESTUAIRE': 'ZONE_4',       # Moins prioritaire (Libreville)
        'HAUT_OGOOUE': 'ZONE_2',    # Priorité élevée (mining areas)
        'MOYEN_OGOOUE': 'ZONE_3',   # Priorité modérée
        'NGOUNIE': 'ZONE_2',        # Priorité élevée (rural)
        'NYANGA': 'ZONE_1',         # Priorité critique (isolé)
        'OGOOUE_IVINDO': 'ZONE_2',  # Priorité élevée (forêt)
        'OGOOUE_LOLO': 'ZONE_1',    # Priorité critique (très rural)
        'OGOOUE_MARITIME': 'ZONE_3', # Priorité modérée (Port-Gentil)
        'WOLEU_NTEM': 'ZONE_2'      # Priorité élevée (frontière)
    }

    def calculate_and_save_assessment(
        self, 
        person_id: int, 
        assessed_by=None, 
        force_recalculate: bool = False
    ) -> VulnerabilityAssessment:
        """
        Calcule et sauvegarde évaluation vulnérabilité complète
        
        Args:
            person_id: ID de la personne à évaluer
            assessed_by: Utilisateur effectuant l'évaluation
            force_recalculate: Forcer recalcul si évaluation existe
            
        Returns:
            VulnerabilityAssessment: Évaluation sauvegardée
        """
        try:
            person = PersonIdentity.objects.get(id=person_id)
            
            # Vérifier évaluation existante
            existing_assessment = VulnerabilityAssessment.objects.filter(
                person=person
            ).order_by('-assessment_date').first()
            
            if existing_assessment and not force_recalculate:
                # Évaluation récente existe (< 6 mois)
                days_since = (timezone.now() - existing_assessment.assessment_date).days
                if days_since < 180:  # 6 mois
                    self.log_operation(
                        'assessment_skipped', 
                        {'person_id': person_id, 'reason': 'recent_assessment_exists'}
                    )
                    return existing_assessment
            
            # Calcul nouvelle évaluation
            assessment_data = self._calculate_vulnerability_assessment(person)
            
            # Sauvegarde avec transaction
            with transaction.atomic():
                assessment = VulnerabilityAssessment.objects.create(
                    person=person,
                    assessed_by=assessed_by,
                    **assessment_data
                )
                
                # Mise à jour champ vulnérabilité sur PersonIdentity
                person.vulnerability_score = assessment.global_score
                person.vulnerability_level = assessment.vulnerability_level
                person.last_vulnerability_assessment = timezone.now()
                person.save(update_fields=[
                    'vulnerability_score', 
                    'vulnerability_level', 
                    'last_vulnerability_assessment'
                ])
                
                self.log_operation(
                    'assessment_calculated', 
                    {
                        'person_id': person_id, 
                        'global_score': float(assessment.global_score),
                        'vulnerability_level': assessment.vulnerability_level
                    }
                )
                
                return assessment
                
        except PersonIdentity.DoesNotExist:
            logger.error(f"PersonIdentity {person_id} not found")
            raise ValueError(f"Personne avec ID {person_id} introuvable")
        except Exception as e:
            logger.error(f"Erreur calcul assessment pour {person_id}: {str(e)}")
            raise

    def _calculate_vulnerability_assessment(self, person: PersonIdentity) -> Dict:
        """
        Calcule évaluation vulnérabilité avec IA contextuelle
        
        Args:
            person: Instance PersonIdentity
            
        Returns:
            Dict: Données évaluation complète
        """
        # Calcul scores par dimension
        dimension_scores = {
            'economic': self._calculate_economic_vulnerability(person),
            'social': self._calculate_social_vulnerability(person),
            'geographic': self._calculate_geographic_vulnerability(person),
            'health': self._calculate_health_vulnerability(person),
            'education': self._calculate_education_vulnerability(person)
        }
        
        # Score global pondéré
        global_score = sum(
            score * self.DIMENSION_WEIGHTS[dimension]
            for dimension, score in dimension_scores.items()
        )
        
        # Détermination niveau vulnérabilité
        vulnerability_level = self._determine_vulnerability_level(global_score)
        
        # Zone priorité géographique
        geographic_priority_zone = self.GEOGRAPHIC_PRIORITY_MAPPING.get(
            person.province, 
            'ZONE_3'
        )
        
        # Génération recommandations IA
        priority_interventions = self._generate_priority_interventions(
            person, dimension_scores, vulnerability_level
        )
        
        # Calcul éligibilité programmes sociaux
        social_programs_eligibility = self._calculate_social_programs_eligibility(
            person, dimension_scores, global_score
        )
        
        # Score de confiance basé sur complétude données
        confidence_score = self._calculate_confidence_score(person)
        
        return {
            'global_score': Decimal(str(round(global_score, 2))),
            'vulnerability_level': vulnerability_level,
            'dimension_scores': dimension_scores,
            'priority_interventions': priority_interventions,
            'social_programs_eligibility': social_programs_eligibility,
            'geographic_priority_zone': geographic_priority_zone,
            'confidence_score': Decimal(str(round(confidence_score, 2)))
        }

    def _calculate_economic_vulnerability(self, person: PersonIdentity) -> float:
        """Calcule vulnérabilité économique (30% du score)"""
        score = 0.0
        
        # Âge et capacité travail
        if person.age:
            if person.age < 18 or person.age > 65:
                score += 30  # Populations non actives
            elif 18 <= person.age <= 25:
                score += 20  # Jeunes difficultés insertion
            elif 55 <= person.age <= 65:
                score += 15  # Préretraite précaire
        
        # Genre (contexte Gabon - inégalités femmes)
        if person.gender == 'F':
            score += 15  # Inégalités économiques femmes
        
        # Situation familiale (chef de ménage)
        if hasattr(person, 'household') and person.household:
            household = person.household
            if household.head_of_household == person:
                # Chef de ménage avec beaucoup de dépendants
                total_members = household.total_members or 1
                if total_members > 6:
                    score += 25  # Grande famille à charge
                elif total_members > 4:
                    score += 15
        
        # Localisation géographique (accès emploi)
        remote_provinces = ['NYANGA', 'OGOOUE_LOLO', 'OGOOUE_IVINDO']
        if person.province in remote_provinces:
            score += 20  # Zones isolées, moins d'opportunités
        
        return min(score, 100.0)

    def _calculate_social_vulnerability(self, person: PersonIdentity) -> float:
        """Calcule vulnérabilité sociale (25% du score)"""
        score = 0.0
        
        # Isolement familial
        if hasattr(person, 'household') and person.household:
            household = person.household
            # Personne seule ou ménage très petit
            if household.total_members == 1:
                score += 25  # Isolement social
            elif household.total_members == 2 and person.age > 65:
                score += 15  # Couple âgé isolé
        else:
            score += 30  # Pas de ménage référencé = isolement
        
        # Vulnérabilités spécifiques par âge/genre
        if person.age and person.age < 5:
            score += 20  # Petite enfance vulnérable
        elif person.age and person.age > 75:
            score += 25  # Grand âge
        
        # Femmes enceintes ou allaitantes (estimation basée sur âge)
        if person.gender == 'F' and person.age and 15 <= person.age <= 45:
            score += 10  # Risque maternité
        
        # Orphelins ou enfants sans parents (complexe à détecter)
        if person.age and person.age < 18:
            # Si pas de parents identifiés dans le ménage
            score += 15  # Enfants vulnérables
        
        return min(score, 100.0)

    def _calculate_geographic_vulnerability(self, person: PersonIdentity) -> float:
        """Calcule vulnérabilité géographique (20% du score)"""
        score = 0.0
        
        # Accessibilité par province
        geographic_scores = {
            'ESTUAIRE': 10,          # Libreville - bien desservie
            'OGOOUE_MARITIME': 20,   # Port-Gentil - moyennement accessible
            'HAUT_OGOOUE': 40,       # Franceville - éloignée mais connectée
            'MOYEN_OGOOUE': 50,      # Lambaréné - accès moyen
            'NGOUNIE': 60,           # Mouila - difficile accès
            'WOLEU_NTEM': 65,        # Oyem - frontière, isolement
            'OGOOUE_IVINDO': 70,     # Makokou - très isolée
            'NYANGA': 80,            # Tchibanga - très difficile accès
            'OGOOUE_LOLO': 85        # Koulamoutou - extrêmement isolée
        }
        
        score += geographic_scores.get(person.province, 50)
        
        # Distance aux services (estimation basée sur coordonnées)
        if person.latitude and person.longitude:
            # Proximité centres urbains (Libreville, Port-Gentil, Franceville)
            urban_centers = [
                (0.4162, 9.4673),   # Libreville
                (-0.7193, 8.7815),  # Port-Gentil
                (-1.6332, 13.5833)  # Franceville
            ]
            
            min_distance = float('inf')
            for center_lat, center_lng in urban_centers:
                # Distance euclidienne approximative
                distance = ((person.latitude - center_lat) ** 2 + 
                           (person.longitude - center_lng) ** 2) ** 0.5
                min_distance = min(min_distance, distance)
            
            # Pénalité distance (échelle approximative)
            if min_distance > 5.0:  # Très éloigné
                score += 20
            elif min_distance > 2.0:  # Éloigné
                score += 10
        
        return min(score, 100.0)

    def _calculate_health_vulnerability(self, person: PersonIdentity) -> float:
        """Calcule vulnérabilité santé (15% du score)"""
        score = 0.0
        
        # Vulnérabilités par âge
        if person.age:
            if person.age < 1:
                score += 40  # Nourrissons très vulnérables
            elif person.age < 5:
                score += 30  # Petite enfance
            elif person.age > 80:
                score += 35  # Grand âge
            elif person.age > 65:
                score += 25  # Personnes âgées
        
        # Vulnérabilités femmes (maternité, santé reproductive)
        if person.gender == 'F' and person.age and 15 <= person.age <= 49:
            score += 15  # Âge reproductif
        
        # Accès aux soins par province (infrastructure sanitaire)
        health_access_scores = {
            'ESTUAIRE': 5,           # CHU Libreville
            'OGOOUE_MARITIME': 10,   # Hôpital Port-Gentil
            'HAUT_OGOOUE': 20,       # Hôpital Franceville
            'MOYEN_OGOOUE': 30,      # Accès limité
            'NGOUNIE': 35,           # Peu d'infrastructure
            'WOLEU_NTEM': 40,        # Infrastructure minimale
            'OGOOUE_IVINDO': 45,     # Très peu d'accès
            'NYANGA': 50,            # Accès très difficile
            'OGOOUE_LOLO': 50        # Accès très difficile
        }
        
        score += health_access_scores.get(person.province, 30)
        
        return min(score, 100.0)

    def _calculate_education_vulnerability(self, person: PersonIdentity) -> float:
        """Calcule vulnérabilité éducation (10% du score)"""
        score = 0.0
        
        # Âge scolaire sans éducation
        if person.age:
            if 6 <= person.age <= 16:
                score += 40  # Âge scolaire obligatoire
            elif 17 <= person.age <= 25:
                score += 25  # Âge formation professionnelle/supérieure
            elif person.age > 25:
                # Adultes sans éducation (estimation)
                score += 20  # Analphabétisme adulte
        
        # Accès éducation par province
        education_access_scores = {
            'ESTUAIRE': 5,           # Université Omar Bongo, écoles
            'OGOOUE_MARITIME': 15,   # Écoles secondaires disponibles
            'HAUT_OGOOUE': 20,       # Université Masuku Franceville
            'MOYEN_OGOOUE': 25,      # Accès limité secondaire
            'WOLEU_NTEM': 30,        # Peu d'établissements
            'NGOUNIE': 35,           # Infrastructure éducative limitée
            'OGOOUE_IVINDO': 40,     # Très peu d'écoles secondaires
            'NYANGA': 45,            # Accès très difficile
            'OGOOUE_LOLO': 45        # Accès très difficile
        }
        
        score += education_access_scores.get(person.province, 25)
        
        # Genre et éducation (inégalités filles en zones rurales)
        if person.gender == 'F' and person.province in ['NYANGA', 'OGOOUE_LOLO', 'OGOOUE_IVINDO']:
            score += 15  # Difficultés scolarisation filles zones reculées
        
        return min(score, 100.0)

    def _determine_vulnerability_level(self, global_score: float) -> str:
        """Détermine niveau vulnérabilité basé sur score global"""
        for level, threshold in self.VULNERABILITY_THRESHOLDS.items():
            if global_score >= threshold:
                return level
        return 'LOW'

    def _generate_priority_interventions(
        self, 
        person: PersonIdentity, 
        dimension_scores: Dict[str, float], 
        vulnerability_level: str
    ) -> List[Dict]:
        """Génère recommandations d'interventions prioritaires"""
        interventions = []
        
        # Interventions économiques
        if dimension_scores['economic'] > 60:
            interventions.append({
                'type': 'ECONOMIC',
                'priority': 'HIGH',
                'intervention': 'Programme formation professionnelle',
                'description': 'Insertion économique via formation qualifiante',
                'estimated_duration_months': 6
            })
            
            if person.gender == 'F':
                interventions.append({
                    'type': 'ECONOMIC',
                    'priority': 'MEDIUM',
                    'intervention': 'Micro-crédit femmes entrepreneures',
                    'description': 'Accès au crédit pour activités génératrices revenus',
                    'estimated_duration_months': 12
                })
        
        # Interventions sociales
        if dimension_scores['social'] > 70:
            interventions.append({
                'type': 'SOCIAL',
                'priority': 'HIGH',
                'intervention': 'Accompagnement social renforcé',
                'description': 'Suivi personnalisé et mise en réseau communautaire',
                'estimated_duration_months': 3
            })
            
            if person.age and person.age > 65:
                interventions.append({
                    'type': 'SOCIAL',
                    'priority': 'HIGH',
                    'intervention': 'Aide à domicile personnes âgées',
                    'description': 'Services d\'aide quotidienne et surveillance',
                    'estimated_duration_months': 12
                })
        
        # Interventions géographiques
        if dimension_scores['geographic'] > 65:
            interventions.append({
                'type': 'GEOGRAPHIC',
                'priority': 'MEDIUM',
                'intervention': 'Amélioration accessibilité services',
                'description': 'Transport vers services ou services mobiles',
                'estimated_duration_months': 6
            })
        
        # Interventions santé
        if dimension_scores['health'] > 50:
            interventions.append({
                'type': 'HEALTH',
                'priority': 'HIGH',
                'intervention': 'Accès soins de santé prioritaire',
                'description': 'Consultation médicale et suivi sanitaire',
                'estimated_duration_months': 1
            })
            
            if person.gender == 'F' and person.age and 15 <= person.age <= 49:
                interventions.append({
                    'type': 'HEALTH',
                    'priority': 'HIGH',
                    'intervention': 'Suivi santé maternelle',
                    'description': 'Consultations prénatales et planning familial',
                    'estimated_duration_months': 9
                })
        
        # Interventions éducation
        if dimension_scores['education'] > 40:
            if person.age and 6 <= person.age <= 16:
                interventions.append({
                    'type': 'EDUCATION',
                    'priority': 'CRITICAL',
                    'intervention': 'Scolarisation obligatoire',
                    'description': 'Inscription et suivi scolaire obligatoire',
                    'estimated_duration_months': 12
                })
            elif person.age and person.age > 16:
                interventions.append({
                    'type': 'EDUCATION',
                    'priority': 'MEDIUM',
                    'intervention': 'Alphabétisation adultes',
                    'description': 'Programme alphabétisation et compétences de base',
                    'estimated_duration_months': 8
                })
        
        # Tri par priorité
        priority_order = {'CRITICAL': 0, 'HIGH': 1, 'MEDIUM': 2, 'LOW': 3}
        interventions.sort(key=lambda x: priority_order.get(x['priority'], 4))
        
        return interventions[:5]  # Max 5 interventions prioritaires

    def _calculate_social_programs_eligibility(
        self, 
        person: PersonIdentity, 
        dimension_scores: Dict[str, float], 
        global_score: float
    ) -> Dict[str, Dict]:
        """Calcule éligibilité automatique programmes sociaux"""
        eligibilities = {}
        
        # Programme Aide Alimentaire
        if global_score > 60 or dimension_scores['economic'] > 70:
            eligibilities['AIDE_ALIMENTAIRE'] = {
                'eligible': True,
                'score': min(90, global_score + 10),
                'recommendation': 'HIGHLY_RECOMMENDED' if global_score > 75 else 'RECOMMENDED',
                'criteria_met': ['vulnerability_threshold', 'economic_criteria']
            }
        
        # Allocations Familiales
        if hasattr(person, 'household') and person.household:
            household = person.household
            children_count = getattr(household, 'members_under_15', 0)
            if children_count > 0 and global_score > 40:
                eligibilities['ALLOCATION_FAMILLE'] = {
                    'eligible': True,
                    'score': min(95, global_score + (children_count * 5)),
                    'recommendation': 'HIGHLY_RECOMMENDED' if children_count > 3 else 'RECOMMENDED',
                    'criteria_met': ['has_children', 'vulnerability_criteria']
                }
        
        # Aide au Logement
        if dimension_scores['economic'] > 50 and dimension_scores['geographic'] > 40:
            eligibilities['AIDE_LOGEMENT'] = {
                'eligible': True,
                'score': min(85, (dimension_scores['economic'] + dimension_scores['geographic']) / 2),
                'recommendation': 'RECOMMENDED',
                'criteria_met': ['economic_vulnerability', 'housing_need']
            }
        
        # Formation Professionnelle
        if person.age and 16 <= person.age <= 35 and dimension_scores['economic'] > 40:
            eligibilities['FORMATION_PROF'] = {
                'eligible': True,
                'score': min(80, dimension_scores['economic'] + (35 - person.age)),
                'recommendation': 'RECOMMENDED' if person.age <= 25 else 'CONDITIONALLY_ELIGIBLE',
                'criteria_met': ['age_criteria', 'economic_need']
            }
        
        # Santé Gratuite
        if dimension_scores['health'] > 45 or global_score > 65:
            eligibilities['SANTE_GRATUITE'] = {
                'eligible': True,
                'score': min(90, max(dimension_scores['health'], global_score)),
                'recommendation': 'HIGHLY_RECOMMENDED',
                'criteria_met': ['health_vulnerability', 'economic_criteria']
            }
        
        # Bourses Éducation
        if person.age and 6 <= person.age <= 25 and dimension_scores['education'] > 35:
            eligibilities['EDUCATION_BOURSE'] = {
                'eligible': True,
                'score': min(85, dimension_scores['education'] + dimension_scores['economic'] / 2),
                'recommendation': 'HIGHLY_RECOMMENDED' if person.age <= 18 else 'RECOMMENDED',
                'criteria_met': ['age_criteria', 'education_need']
            }
        
        # Insertion Jeunes
        if person.age and 16 <= person.age <= 30 and dimension_scores['economic'] > 45:
            eligibilities['INSERTION_JEUNES'] = {
                'eligible': True,
                'score': min(80, dimension_scores['economic'] + (30 - person.age)),
                'recommendation': 'RECOMMENDED',
                'criteria_met': ['youth_criteria', 'employment_need']
            }
        
        return eligibilities

    def _calculate_confidence_score(self, person: PersonIdentity) -> float:
        """Calcule score de confiance basé sur complétude des données"""
        total_fields = 0
        completed_fields = 0
        
        # Champs essentiels
        essential_fields = [
            'first_name', 'last_name', 'age', 'gender', 'province'
        ]
        
        for field in essential_fields:
            total_fields += 1
            if getattr(person, field, None):
                completed_fields += 1
        
        # Champs optionnels mais importants
        optional_fields = [
            'phone_number', 'nip', 'latitude', 'longitude'
        ]
        
        for field in optional_fields:
            total_fields += 1
            if getattr(person, field, None):
                completed_fields += 0.7  # Pondération moindre
        
        # Données ménage
        if hasattr(person, 'household') and person.household:
            total_fields += 2
            completed_fields += 2
            
            household = person.household
            if getattr(household, 'total_members', None):
                completed_fields += 1
            total_fields += 1
        
        # Score de confiance (0-100)
        if total_fields > 0:
            confidence = (completed_fields / total_fields) * 100
            return min(100.0, confidence)
        
        return 50.0  # Score par défaut si pas de données

    def bulk_calculate_assessments(
        self, 
        person_ids: List[int] = None, 
        province: str = None, 
        assessed_by=None
    ) -> Dict:
        """
        Calcul en lot d'évaluations vulnérabilité
        
        Args:
            person_ids: Liste IDs personnes (optionnel)
            province: Province pour calcul massif (optionnel)
            assessed_by: Utilisateur effectuant les évaluations
            
        Returns:
            Dict: Résultats du traitement en lot
        """
        results = {'success': 0, 'errors': 0, 'details': []}
        
        try:
            # Déterminer les personnes à traiter
            if person_ids:
                persons = PersonIdentity.objects.filter(id__in=person_ids)
            elif province:
                persons = PersonIdentity.objects.filter(province=province)
            else:
                raise ValueError("person_ids ou province requis")
            
            total_persons = persons.count()
            self.log_operation(
                'bulk_assessment_started', 
                {'total_persons': total_persons, 'province': province}
            )
            
            # Traitement par lots de 50
            batch_size = 50
            for i in range(0, total_persons, batch_size):
                batch_persons = persons[i:i + batch_size]
                
                for person in batch_persons:
                    try:
                        assessment = self.calculate_and_save_assessment(
                            person_id=person.id,
                            assessed_by=assessed_by,
                            force_recalculate=False
                        )
                        
                        results['success'] += 1
                        results['details'].append({
                            'person_id': person.id,
                            'status': 'success',
                            'global_score': float(assessment.global_score),
                            'vulnerability_level': assessment.vulnerability_level
                        })
                        
                    except Exception as e:
                        results['errors'] += 1
                        results['details'].append({
                            'person_id': person.id,
                            'status': 'error',
                            'error': str(e)
                        })
                        logger.error(f"Erreur assessment personne {person.id}: {str(e)}")
            
            self.log_operation(
                'bulk_assessment_completed', 
                {
                    'total_processed': results['success'] + results['errors'],
                    'success': results['success'],
                    'errors': results['errors']
                }
            )
            
            return results
            
        except Exception as e:
            logger.error(f"Erreur bulk assessment: {str(e)}")
            raise

    def get_vulnerability_statistics(
        self, 
        province: str = None, 
        zone: str = None
    ) -> Dict:
        """
        Génère statistiques vulnérabilité pour dashboards
        
        Args:
            province: Filtrer par province (optionnel)
            zone: Filtrer par zone priorité (optionnel)
            
        Returns:
            Dict: Statistiques complètes vulnérabilité
        """
        try:
            queryset = VulnerabilityAssessment.objects.all()
            
            # Filtres
            if province:
                queryset = queryset.filter(person__province=province)
            if zone:
                queryset = queryset.filter(geographic_priority_zone=zone)
            
            # Statistiques globales
            total_assessments = queryset.count()
            
            if total_assessments == 0:
                return {
                    'total_assessments': 0,
                    'message': 'Aucune évaluation trouvée pour les critères spécifiés'
                }
            
            # Distribution par niveau vulnérabilité
            vulnerability_distribution = list(
                queryset.values('vulnerability_level')
                .annotate(count=Count('id'))
                .order_by('vulnerability_level')
            )
            
            # Scores moyens par dimension
            avg_scores = {
                'global_score': queryset.aggregate(Avg('global_score'))['global_score__avg'],
                'confidence_score': queryset.aggregate(Avg('confidence_score'))['confidence_score__avg']
            }
            
            # Distribution par province
            province_distribution = list(
                queryset.values('person__province')
                .annotate(
                    count=Count('id'),
                    avg_score=Avg('global_score')
                )
                .order_by('-avg_score')
            )
            
            # Distribution par zone priorité
            zone_distribution = list(
                queryset.values('geographic_priority_zone')
                .annotate(
                    count=Count('id'),
                    avg_score=Avg('global_score')
                )
                .order_by('-avg_score')
            )
            
            # Tendances temporelles (derniers 6 mois)
            six_months_ago = timezone.now() - timezone.timedelta(days=180)
            recent_trends = list(
                queryset.filter(assessment_date__gte=six_months_ago)
                .extra({'month': "date_trunc('month', assessment_date)"})
                .values('month')
                .annotate(
                    count=Count('id'),
                    avg_score=Avg('global_score')
                )
                .order_by('month')
            )
            
            return {
                'total_assessments': total_assessments,
                'vulnerability_distribution': vulnerability_distribution,
                'average_scores': avg_scores,
                'province_distribution': province_distribution,
                'zone_distribution': zone_distribution,
                'recent_trends': recent_trends,
                'filters_applied': {
                    'province': province,
                    'zone': zone
                },
                'generated_at': timezone.now().isoformat()
            }
            
        except Exception as e:
            logger.error(f"Erreur génération statistiques: {str(e)}")
            raise
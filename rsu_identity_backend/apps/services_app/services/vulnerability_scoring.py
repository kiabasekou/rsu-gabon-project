# ===================================================================
# RSU GABON - SERVICE VULNERABILITY SCORING COMPLET
# Standards Top 1% - Intelligence Artificielle contextualisée
# ===================================================================

import logging
from typing import Dict, List, Optional, Tuple
from decimal import Decimal
from django.db import transaction
from django.utils import timezone
from django.db.models import Count, Avg, Q

from apps.identity_app.models import PersonIdentity
from ..models import VulnerabilityAssessment, GeographicPriorityZone
from services.base_service import BaseService

logger = logging.getLogger(__name__)


class VulnerabilityService(BaseService):
    """
    Service de calcul intelligente vulnérabilité
    Algorithmes IA contextualisés pour le Gabon
    """
    
    # Pondérations dimensions vulnérabilité (adapté au contexte Gabon)
    DIMENSION_WEIGHTS = {
        'household_composition': 0.20,  # Composition ménage
        'economic': 0.30,               # Économique (revenus, emploi)
        'social': 0.20,                 # Social (éducation, santé)
        'geographic': 0.15,             # Géographique (accès services)
        'contextual': 0.15              # Contextuel (âge, genre, handicap)
    }
    
    # Seuils vulnérabilité
    VULNERABILITY_THRESHOLDS = {
        'CRITICAL': 75,
        'HIGH': 50,
        'MODERATE': 25,
        'LOW': 0
    }
    
    # Zones géographiques prioritaires Gabon
    GEOGRAPHIC_PRIORITY_MAPPING = {
        'ESTUAIRE': 'ZONE_4',           # Moins prioritaire (Libreville)
        'HAUT_OGOOUE': 'ZONE_2',        # Priorité élevée (mining)
        'MOYEN_OGOOUE': 'ZONE_3',       # Priorité modérée
        'NGOUNIE': 'ZONE_2',            # Priorité élevée (rural)
        'NYANGA': 'ZONE_1',             # Priorité CRITIQUE (isolé)
        'OGOOUE_IVINDO': 'ZONE_1',      # Priorité CRITIQUE (forêt)
        'OGOOUE_LOLO': 'ZONE_1',        # Priorité CRITIQUE (très rural)
        'OGOOUE_MARITIME': 'ZONE_3',    # Priorité modérée (Port-Gentil)
        'WOLEU_NTEM': 'ZONE_2'          # Priorité élevée (frontière)
    }
    
    # Seuils économiques Gabon (FCFA/mois)
    EXTREME_POVERTY_THRESHOLD = 50000
    POVERTY_THRESHOLD = 100000
    MIDDLE_CLASS_THRESHOLD = 300000

    @transaction.atomic
    def calculate_and_save_assessment(
        self, 
        person_id: int, 
        assessed_by=None, 
        force_recalculate: bool = False
    ) -> VulnerabilityAssessment:
        """
        Calcule et sauvegarde évaluation vulnérabilité complète
        
        Args:
            person_id: ID de la personne à évaluer
            assessed_by: Utilisateur effectuant l'évaluation
            force_recalculate: Forcer recalcul si évaluation existe
            
        Returns:
            VulnerabilityAssessment: Évaluation sauvegardée
        """
        try:
            # Récupération personne avec données liées
            person = PersonIdentity.objects.select_related(
                'household'
            ).get(id=person_id)
            
            # Vérifier si évaluation existe déjà
            existing_assessment = VulnerabilityAssessment.objects.filter(
                person=person,
                is_active=True
            ).first()
            
            if existing_assessment and not force_recalculate:
                self.log_operation(
                    'assessment_already_exists',
                    {'person_id': person_id, 'assessment_id': existing_assessment.id}
                )
                return existing_assessment
            
            # Calcul scores par dimension
            household_score = self._score_household_composition(person)
            economic_score = self._score_economic_vulnerability(person)
            social_score = self._score_social_vulnerability(person)
            geographic_score = self._score_geographic_vulnerability(person)
            contextual_score = self._score_contextual_vulnerability(person)
            
            # Score global pondéré
            global_score = self._calculate_global_score({
                'household_composition': household_score,
                'economic': economic_score,
                'social': social_score,
                'geographic': geographic_score,
                'contextual': contextual_score
            })
            
            # Niveau vulnérabilité
            vulnerability_level = self._determine_vulnerability_level(global_score)
            
            # Identification facteurs
            vulnerability_factors = self._identify_vulnerability_factors(person, {
                'household': household_score,
                'economic': economic_score,
                'social': social_score,
                'geographic': geographic_score,
                'contextual': contextual_score
            })
            
            # Recommandations
            recommendations = self._generate_recommendations(
                person, 
                vulnerability_level, 
                vulnerability_factors
            )
            
            # Zone prioritaire
            priority_zone = self.GEOGRAPHIC_PRIORITY_MAPPING.get(
                person.province, 
                'ZONE_4'
            )
            
            # Désactiver anciennes évaluations
            if existing_assessment:
                existing_assessment.is_active = False
                existing_assessment.save()
            
            # Créer nouvelle évaluation
            assessment = VulnerabilityAssessment.objects.create(
                person=person,
                global_score=Decimal(str(global_score)),
                vulnerability_level=vulnerability_level,
                household_composition_score=Decimal(str(household_score)),
                economic_vulnerability_score=Decimal(str(economic_score)),
                social_vulnerability_score=Decimal(str(social_score)),
                geographic_vulnerability_score=Decimal(str(geographic_score)),
                contextual_vulnerability_score=Decimal(str(contextual_score)),
                vulnerability_factors=vulnerability_factors,
                recommendations=recommendations,
                geographic_priority_zone=priority_zone,
                assessed_by=assessed_by,
                is_active=True
            )
            
            self.log_operation(
                'vulnerability_assessment_created',
                {
                    'person_id': person_id,
                    'assessment_id': assessment.id,
                    'global_score': float(global_score),
                    'vulnerability_level': vulnerability_level
                }
            )
            
            return assessment
            
        except PersonIdentity.DoesNotExist:
            logger.error(f"Personne {person_id} introuvable")
            raise
        except Exception as e:
            logger.error(f"Erreur calcul assessment personne {person_id}: {str(e)}")
            raise

    def _score_household_composition(self, person: PersonIdentity) -> float:
        """
        Score vulnérabilité composition ménage (0-100)
        
        Facteurs évalués:
        - Taille du ménage vs ressources
        - Ratio de dépendance (enfants + personnes âgées)
        - Chef de ménage vulnérable (femme seule, personne âgée)
        - Présence personnes à besoins spéciaux
        
        Args:
            person: Instance PersonIdentity
            
        Returns:
            float: Score 0-100 (100 = très vulnérable)
        """
        score = 0.0
        
        try:
            household = person.household
            if not household:
                return 40.0  # Score modéré si pas de ménage défini
            
            # 1. Taille ménage (30 points max)
            household_size = household.household_size or 1
            if household_size >= 8:
                score += 30
            elif household_size >= 6:
                score += 25
            elif household_size >= 4:
                score += 15
            elif household_size <= 1:
                score += 20  # Isolement social
            
            # 2. Ratio de dépendance (30 points max)
            dependents = (household.children_count or 0) + (household.elderly_count or 0)
            if household_size > 0:
                dependency_ratio = dependents / household_size
                if dependency_ratio >= 0.7:
                    score += 30
                elif dependency_ratio >= 0.5:
                    score += 20
                elif dependency_ratio >= 0.3:
                    score += 10
            
            # 3. Vulnérabilité chef de ménage (25 points max)
            if household.head_of_household_id == person.id:
                # Femme chef de ménage
                if person.gender == 'F':
                    score += 10
                # Chef de ménage âgé
                if person.age and person.age >= 65:
                    score += 15
                # Chef de ménage jeune
                if person.age and person.age < 25:
                    score += 10
            
            # 4. Besoins spéciaux (15 points max)
            if household.has_disabled_members:
                score += 10
            if household.has_chronic_illness_members:
                score += 5
                
            return min(score, 100.0)
            
        except Exception as e:
            logger.error(f"Erreur calcul household composition: {str(e)}")
            return 50.0  # Score neutre en cas d'erreur

    def _score_economic_vulnerability(self, person: PersonIdentity) -> float:
        """
        Score vulnérabilité économique (0-100)
        
        Facteurs évalués:
        - Niveau de revenus vs seuils pauvreté Gabon
        - Statut d'emploi et stabilité
        - Accès aux services financiers
        - Dépendance à l'aide sociale
        
        Args:
            person: Instance PersonIdentity
            
        Returns:
            float: Score 0-100 (100 = très vulnérable)
        """
        score = 0.0
        
        try:
            household = person.household
            
            # 1. Niveau de revenus (40 points max)
            monthly_income = household.monthly_income if household else 0
            if monthly_income <= self.EXTREME_POVERTY_THRESHOLD:
                score += 40  # Pauvreté extrême
            elif monthly_income <= self.POVERTY_THRESHOLD:
                score += 30  # Sous seuil pauvreté
            elif monthly_income <= self.MIDDLE_CLASS_THRESHOLD:
                score += 15  # Revenus faibles
            
            # 2. Emploi et stabilité (30 points max)
            employment_status = household.primary_income_source if household else None
            if employment_status == 'UNEMPLOYED' or not employment_status:
                score += 30
            elif employment_status in ['INFORMAL', 'DAILY_WORKER']:
                score += 20
            elif employment_status == 'SELF_EMPLOYED':
                score += 10
            
            # 3. Accès services financiers (20 points max)
            has_bank_account = household.has_bank_account if household else False
            has_savings = household.has_savings if household else False
            
            if not has_bank_account:
                score += 12
            if not has_savings:
                score += 8
            
            # 4. Dépendance aide sociale (10 points max)
            receives_social_aid = household.receives_social_aid if household else False
            if receives_social_aid:
                score += 10  # Indicateur besoin
                
            return min(score, 100.0)
            
        except Exception as e:
            logger.error(f"Erreur calcul economic vulnerability: {str(e)}")
            return 50.0

    def _score_social_vulnerability(self, person: PersonIdentity) -> float:
        """
        Score vulnérabilité sociale (0-100)
        
        Facteurs évalués:
        - Niveau d'éducation
        - Accès aux soins de santé
        - Réseau social et communautaire
        - Stigmatisation ou exclusion
        
        Args:
            person: Instance PersonIdentity
            
        Returns:
            float: Score 0-100 (100 = très vulnérable)
        """
        score = 0.0
        
        try:
            # 1. Niveau d'éducation (35 points max)
            education_level = person.education_level
            if education_level == 'NONE' or not education_level:
                score += 35
            elif education_level == 'PRIMARY':
                score += 25
            elif education_level == 'SECONDARY':
                score += 15
            elif education_level == 'VOCATIONAL':
                score += 10
            
            # 2. Accès aux soins (30 points max)
            has_health_insurance = person.has_health_insurance if hasattr(person, 'has_health_insurance') else False
            distance_health_center = person.distance_to_health_center if hasattr(person, 'distance_to_health_center') else None
            
            if not has_health_insurance:
                score += 15
            
            if distance_health_center:
                if distance_health_center >= 20:  # > 20km
                    score += 15
                elif distance_health_center >= 10:
                    score += 10
                elif distance_health_center >= 5:
                    score += 5
            else:
                score += 10  # Absence d'info = vulnérabilité
            
            # 3. Réseau social (20 points max)
            is_isolated = person.is_socially_isolated if hasattr(person, 'is_socially_isolated') else False
            household = person.household
            
            if is_isolated:
                score += 15
            
            if not household or household.household_size <= 1:
                score += 5  # Isolement
            
            # 4. Handicap ou maladie chronique (15 points max)
            if person.has_disability:
                score += 10
            if person.has_chronic_illness:
                score += 5
                
            return min(score, 100.0)
            
        except Exception as e:
            logger.error(f"Erreur calcul social vulnerability: {str(e)}")
            return 50.0

    def _score_geographic_vulnerability(self, person: PersonIdentity) -> float:
        """
        Score vulnérabilité géographique (0-100)
        
        Facteurs évalués:
        - Province et niveau d'isolement
        - Zone rurale vs urbaine
        - Accès infrastructures (routes, services)
        - Distance services essentiels
        
        Args:
            person: Instance PersonIdentity
            
        Returns:
            float: Score 0-100 (100 = très vulnérable)
        """
        score = 0.0
        
        try:
            # 1. Priorité province (40 points max)
            province = person.province
            priority_zone = self.GEOGRAPHIC_PRIORITY_MAPPING.get(province, 'ZONE_4')
            
            zone_scores = {
                'ZONE_1': 40,  # Critique: NYANGA, OGOOUE_LOLO, OGOOUE_IVINDO
                'ZONE_2': 30,  # Élevée: HAUT_OGOOUE, NGOUNIE, WOLEU_NTEM
                'ZONE_3': 15,  # Modérée: MOYEN_OGOOUE, OGOOUE_MARITIME
                'ZONE_4': 5    # Standard: ESTUAIRE
            }
            score += zone_scores.get(priority_zone, 20)
            
            # 2. Zone rurale vs urbaine (30 points max)
            residence_type = person.residence_type if hasattr(person, 'residence_type') else 'URBAN'
            if residence_type == 'RURAL':
                score += 30
            elif residence_type == 'PERI_URBAN':
                score += 15
            
            # 3. Accessibilité (20 points max)
            road_access = person.road_access_quality if hasattr(person, 'road_access_quality') else 'GOOD'
            access_scores = {
                'NONE': 20,
                'POOR': 15,
                'FAIR': 10,
                'GOOD': 5,
                'EXCELLENT': 0
            }
            score += access_scores.get(road_access, 10)
            
            # 4. Distance services (10 points max)
            distance_admin = person.distance_to_admin_center if hasattr(person, 'distance_to_admin_center') else None
            if distance_admin:
                if distance_admin >= 50:
                    score += 10
                elif distance_admin >= 30:
                    score += 7
                elif distance_admin >= 15:
                    score += 4
            else:
                score += 5  # Absence info
                
            return min(score, 100.0)
            
        except Exception as e:
            logger.error(f"Erreur calcul geographic vulnerability: {str(e)}")
            return 50.0

    def _score_contextual_vulnerability(self, person: PersonIdentity) -> float:
        """
        Score vulnérabilité contextuelle (0-100)
        
        Facteurs évalués:
        - Âge (enfants, personnes âgées)
        - Genre et vulnérabilités spécifiques
        - Situation familiale (orphelin, veuf)
        - Événements traumatiques récents
        
        Args:
            person: Instance PersonIdentity
            
        Returns:
            float: Score 0-100 (100 = très vulnérable)
        """
        score = 0.0
        
        try:
            # 1. Âge (30 points max)
            age = person.age or 0
            if age < 5:
                score += 25  # Petite enfance vulnérable
            elif age < 18:
                score += 15  # Mineur
            elif age >= 70:
                score += 30  # Personne très âgée
            elif age >= 60:
                score += 20  # Personne âgée
            
            # 2. Genre et facteurs associés (25 points max)
            if person.gender == 'F':
                # Femmes avec facteurs aggravants
                if age >= 60:
                    score += 10  # Femme âgée
                
                household = person.household
                if household and household.head_of_household_id == person.id:
                    children = household.children_count or 0
                    if children > 0:
                        score += 15  # Mère chef de ménage
            
            # 3. Situation familiale (25 points max)
            marital_status = person.marital_status if hasattr(person, 'marital_status') else None
            if marital_status == 'WIDOWED':
                score += 15
            elif marital_status == 'DIVORCED':
                score += 10
            
            is_orphan = person.is_orphan if hasattr(person, 'is_orphan') else False
            if is_orphan and age < 18:
                score += 25  # Orphelin mineur très vulnérable
            
            # 4. Traumatismes récents (20 points max)
            recent_displacement = person.recently_displaced if hasattr(person, 'recently_displaced') else False
            recent_loss = person.recent_family_loss if hasattr(person, 'recent_family_loss') else False
            
            if recent_displacement:
                score += 12
            if recent_loss:
                score += 8
                
            return min(score, 100.0)
            
        except Exception as e:
            logger.error(f"Erreur calcul contextual vulnerability: {str(e)}")
            return 50.0

    def _calculate_global_score(self, dimension_scores: Dict[str, float]) -> float:
        """
        Calcule score global pondéré
        
        Args:
            dimension_scores: Scores par dimension
            
        Returns:
            float: Score global 0-100
        """
        try:
            global_score = sum(
                dimension_scores.get(dim, 0) * weight
                for dim, weight in self.DIMENSION_WEIGHTS.items()
            )
            
            return round(global_score, 2)
            
        except Exception as e:
            logger.error(f"Erreur calcul global score: {str(e)}")
            return 50.0

    def _determine_vulnerability_level(self, global_score: float) -> str:
        """
        Détermine niveau vulnérabilité selon seuils
        
        Args:
            global_score: Score global
            
        Returns:
            str: Niveau vulnérabilité (CRITICAL, HIGH, MODERATE, LOW)
        """
        if global_score >= self.VULNERABILITY_THRESHOLDS['CRITICAL']:
            return 'CRITICAL'
        elif global_score >= self.VULNERABILITY_THRESHOLDS['HIGH']:
            return 'HIGH'
        elif global_score >= self.VULNERABILITY_THRESHOLDS['MODERATE']:
            return 'MODERATE'
        else:
            return 'LOW'

    def _identify_vulnerability_factors(
        self, 
        person: PersonIdentity, 
        scores: Dict[str, float]
    ) -> List[str]:
        """
        Identifie facteurs de vulnérabilité principaux
        
        Args:
            person: Instance PersonIdentity
            scores: Scores par dimension
            
        Returns:
            List[str]: Liste facteurs identifiés
        """
        factors = []
        
        try:
            # Analyse par dimension (seuil 60 = facteur significatif)
            if scores.get('household', 0) >= 60:
                household = person.household
                if household:
                    if household.household_size >= 6:
                        factors.append("Ménage nombreux (ressources limitées)")
                    if household.children_count and household.children_count >= 4:
                        factors.append("Nombreux enfants à charge")
            
            if scores.get('economic', 0) >= 60:
                factors.append("Vulnérabilité économique élevée")
                household = person.household
                if household and household.monthly_income <= self.EXTREME_POVERTY_THRESHOLD:
                    factors.append("Revenus sous seuil pauvreté extrême")
            
            if scores.get('social', 0) >= 60:
                if person.education_level in ['NONE', 'PRIMARY']:
                    factors.append("Niveau éducation faible")
                if person.has_disability:
                    factors.append("Personne en situation de handicap")
                if person.has_chronic_illness:
                    factors.append("Maladie chronique")
            
            if scores.get('geographic', 0) >= 60:
                priority_zone = self.GEOGRAPHIC_PRIORITY_MAPPING.get(person.province, 'ZONE_4')
                if priority_zone == 'ZONE_1':
                    factors.append(f"Zone géographique isolée ({person.province})")
            
            if scores.get('contextual', 0) >= 60:
                if person.age and person.age < 5:
                    factors.append("Enfant en bas âge")
                elif person.age and person.age >= 65:
                    factors.append("Personne âgée")
                    
            if not factors:
                factors.append("Aucun facteur critique identifié")
                
            return factors
            
        except Exception as e:
            logger.error(f"Erreur identification facteurs: {str(e)}")
            return ["Erreur analyse facteurs"]

    def _generate_recommendations(
        self, 
        person: PersonIdentity, 
        vulnerability_level: str,
        factors: List[str]
    ) -> List[str]:
        """
        Génère recommandations d'intervention
        
        Args:
            person: Instance PersonIdentity
            vulnerability_level: Niveau vulnérabilité
            factors: Facteurs identifiés
            
        Returns:
            List[str]: Recommandations d'intervention
        """
        recommendations = []
        
        try:
            # Recommandations selon niveau
            if vulnerability_level == 'CRITICAL':
                recommendations.append("⚠️ INTERVENTION URGENTE REQUISE")
                recommendations.append("Prioriser pour allocations d'urgence")
                recommendations.append("Visite terrain pour évaluation détaillée")
            elif vulnerability_level == 'HIGH':
                recommendations.append("Éligible programmes d'assistance prioritaire")
                recommendations.append("Suivi rapproché conseillé")
            
            # Recommandations ciblées
            household = person.household
            
            # Économique
            if household and household.monthly_income <= self.POVERTY_THRESHOLD:
                recommendations.append("Programme transferts monétaires ciblés")
                recommendations.append("Accompagnement activités génératrices revenus")
            
            # Social
            if person.education_level in ['NONE', 'PRIMARY']:
                recommendations.append("Programme alphabétisation / formation professionnelle")
            
            if person.has_disability or person.has_chronic_illness:
                recommendations.append("Orientation services santé spécialisés")
                recommendations.append("Aide technique / appareillage si nécessaire")
            
            # Famille
            if household and household.children_count and household.children_count >= 3:
                recommendations.append("Allocations familiales / bourses scolaires")
            
            # Géographique
            priority_zone = self.GEOGRAPHIC_PRIORITY_MAPPING.get(person.province, 'ZONE_4')
            if priority_zone == 'ZONE_1':
                recommendations.append("Programmes ciblés zones isolées")
                recommendations.append("Faciliter accès services mobiles")
            
            if not recommendations:
                recommendations.append("Suivi régulier de la situation")
                
            return recommendations
            
        except Exception as e:
            logger.error(f"Erreur génération recommandations: {str(e)}")
            return ["Erreur génération recommandations"]

    def bulk_calculate_assessments(
        self,
        person_ids: List[int],
        assessed_by=None,
        batch_size: int = 50
    ) -> Dict:
        """
        Calcul en masse des évaluations de vulnérabilité
        
        Args:
            person_ids: Liste IDs personnes à évaluer
            assessed_by: Utilisateur effectuant évaluations
            batch_size: Taille des lots de traitement
            
        Returns:
            Dict: Statistiques succès/erreurs
        """
        try:
            results = {
                'success': 0,
                'errors': 0,
                'details': []
            }
            
            persons = PersonIdentity.objects.filter(id__in=person_ids)
            total_persons = persons.count()
            
            self.log_operation(
                'bulk_assessment_started',
                {
                    'total_persons': total_persons,
                    'batch_size': batch_size
                }
            )
            
            # Traitement par lots
            for i in range(0, total_persons, batch_size):
                batch_persons = persons[i:i + batch_size]
                
                for person in batch_persons:
                    try:
                        assessment = self.calculate_and_save_assessment(
                            person_id=person.id,
                            assessed_by=assessed_by,
                            force_recalculate=False
                        )
                        
                        results['success'] += 1
                        results['details'].append({
                            'person_id': person.id,
                            'status': 'success',
                            'global_score': float(assessment.global_score),
                            'vulnerability_level': assessment.vulnerability_level
                        })
                        
                    except Exception as e:
                        results['errors'] += 1
                        results['details'].append({
                            'person_id': person.id,
                            'status': 'error',
                            'error': str(e)
                        })
                        logger.error(f"Erreur assessment personne {person.id}: {str(e)}")
            
            self.log_operation(
                'bulk_assessment_completed',
                {
                    'total_processed': results['success'] + results['errors'],
                    'success': results['success'],
                    'errors': results['errors']
                }
            )
            
            return results
            
        except Exception as e:
            logger.error(f"Erreur bulk assessment: {str(e)}")
            raise

    def get_vulnerability_statistics(
        self, 
        province: str = None, 
        zone: str = None
    ) -> Dict:
        """
        Génère statistiques vulnérabilité pour dashboards
        
        Args:
            province: Filtrer par province (optionnel)
            zone: Filtrer par zone priorité (optionnel)
            
        Returns:
            Dict: Statistiques complètes vulnérabilité
        """
        try:
            queryset = VulnerabilityAssessment.objects.filter(is_active=True)
            
            # Filtres
            if province:
                queryset = queryset.filter(person__province=province)
            if zone:
                queryset = queryset.filter(geographic_priority_zone=zone)
            
            # Statistiques globales
            total_assessments = queryset.count()
            
            if total_assessments == 0:
                return {
                    'total_assessments': 0,
                    'message': 'Aucune évaluation disponible'
                }
            
            # Distribution par niveau
            level_distribution = queryset.values('vulnerability_level').annotate(
                count=Count('id')
            ).order_by('vulnerability_level')
            
            # Scores moyens par dimension
            avg_scores = queryset.aggregate(
                avg_global=Avg('global_score'),
                avg_household=Avg('household_composition_score'),
                avg_economic=Avg('economic_vulnerability_score'),
                avg_social=Avg('social_vulnerability_score'),
                avg_geographic=Avg('geographic_vulnerability_score'),
                avg_contextual=Avg('contextual_vulnerability_score')
            )
            
            # Distribution zones prioritaires
            zone_distribution = queryset.values('geographic_priority_zone').annotate(
                count=Count('id')
            ).order_by('geographic_priority_zone')
            
            # Top provinces vulnérables
            province_stats = queryset.values('person__province').annotate(
                count=Count('id'),
                avg_score=Avg('global_score')
            ).order_by('-avg_score')[:5]
            
            statistics = {
                'total_assessments': total_assessments,
                'level_distribution': {
                    item['vulnerability_level']: item['count'] 
                    for item in level_distribution
                },
                'average_scores': {
                    'global': float(avg_scores['avg_global'] or 0),
                    'household_composition': float(avg_scores['avg_household'] or 0),
                    'economic': float(avg_scores['avg_economic'] or 0),
                    'social': float(avg_scores['avg_social'] or 0),
                    'geographic': float(avg_scores['avg_geographic'] or 0),
                    'contextual': float(avg_scores['avg_contextual'] or 0)
                },
                'zone_distribution': {
                    item['geographic_priority_zone']: item['count']
                    for item in zone_distribution
                },
                'top_vulnerable_provinces': [
                    {
                        'province': item['person__province'],
                        'count': item['count'],
                        'avg_score': float(item['avg_score'])
                    }
                    for item in province_stats
                ],
                'filters_applied': {
                    'province': province,
                    'zone': zone
                }
            }
            
            self.log_operation(
                'vulnerability_statistics_generated',
                {'total_assessments': total_assessments}
            )
            
            return statistics
            
        except Exception as e:
            logger.error(f"Erreur génération statistiques: {str(e)}")
            raise

    def get_persons_by_vulnerability_level(
        self,
        vulnerability_level: str,
        limit: int = 100
    ) -> List[VulnerabilityAssessment]:
        """
        Récupère personnes par niveau vulnérabilité
        
        Args:
            vulnerability_level: Niveau (CRITICAL, HIGH, MODERATE, LOW)
            limit: Nombre maximum de résultats
            
        Returns:
            List[VulnerabilityAssessment]: Évaluations correspondantes
        """
        try:
            assessments = VulnerabilityAssessment.objects.filter(
                vulnerability_level=vulnerability_level,
                is_active=True
            ).select_related('person').order_by('-global_score')[:limit]
            
            self.log_operation(
                'persons_retrieved_by_level',
                {
                    'vulnerability_level': vulnerability_level,
                    'count': assessments.count()
                }
            )
            
            return list(assessments)
            
        except Exception as e:
            logger.error(f"Erreur récupération personnes: {str(e)}")
            raise

    def identify_priority_interventions(
        self,
        province: str = None,
        max_results: int = 50
    ) -> List[Dict]:
        """
        Identifie personnes prioritaires pour interventions
        
        Args:
            province: Filtrer par province (optionnel)
            max_results: Nombre maximum de résultats
            
        Returns:
            List[Dict]: Personnes prioritaires avec détails
        """
        try:
            queryset = VulnerabilityAssessment.objects.filter(
                vulnerability_level__in=['CRITICAL', 'HIGH'],
                is_active=True
            ).select_related('person')
            
            if province:
                queryset = queryset.filter(person__province=province)
            
            # Trier par score décroissant
            priority_assessments = queryset.order_by('-global_score')[:max_results]
            
            priority_list = []
            for assessment in priority_assessments:
                priority_list.append({
                    'person_id': assessment.person.id,
                    'rsu_id': assessment.person.rsu_id,
                    'full_name': assessment.person.full_name,
                    'age': assessment.person.age,
                    'province': assessment.person.province,
                    'vulnerability_level': assessment.vulnerability_level,
                    'global_score': float(assessment.global_score),
                    'priority_zone': assessment.geographic_priority_zone,
                    'key_factors': assessment.vulnerability_factors[:3],  # Top 3
                    'recommendations': assessment.recommendations[:2]  # Top 2
                })
            
            self.log_operation(
                'priority_interventions_identified',
                {
                    'count': len(priority_list),
                    'province': province
                }
            )
            
            return priority_list
            
        except Exception as e:
            logger.error(f"Erreur identification priorités: {str(e)}")
            raise
"""
🇬🇦 RSU GABON - SCORING VULNÉRABILITÉ AVANCÉ
Standards Top 1% - Intelligence Artificielle Contextuelle Gabon
====================================================================

Système de scoring multi-dimensionnel adapté au contexte socio-économique gabonais
Conforme aux standards ID4D Principles et audit Banque Mondiale
"""

import logging
import numpy as np
from typing import Dict, List, Tuple, Optional
from decimal import Decimal
from dataclasses import dataclass
from enum import Enum

logger = logging.getLogger(__name__)

class VulnerabilityLevel(Enum):
    """Niveaux de vulnérabilité selon standards gouvernementaux"""
    CRITICAL = "CRITICAL"      # 75-100: Intervention urgente
    HIGH = "HIGH"              # 50-74: Intervention prioritaire  
    MODERATE = "MODERATE"      # 25-49: Surveillance active
    LOW = "LOW"                # 0-24: Suivi régulier

@dataclass
class DimensionScore:
    """Structure score par dimension"""
    dimension: str
    score: float
    weight: float
    contributing_factors: List[str]
    risk_indicators: List[str]
    recommendations: List[str]

@dataclass
class VulnerabilityAssessment:
    """Évaluation complète vulnérabilité"""
    global_score: float
    vulnerability_level: VulnerabilityLevel
    dimension_scores: Dict[str, DimensionScore]
    priority_interventions: List[str]
    social_programs_eligibility: Dict[str, float]
    geographic_priority_zone: str
    assessment_date: str
    confidence_score: float

class GabonVulnerabilityScoringEngine:
    """
    Moteur de scoring vulnérabilité contextualisé Gabon
    Algorithme IA avec 5 dimensions prioritaires gouvernementales
    """
    
    # === SEUILS ÉCONOMIQUES GABON (FCFA) ===
    ECONOMIC_THRESHOLDS = {
        'EXTREME_POVERTY': 75_000,      # Pauvreté extrême
        'POVERTY_LINE': 150_000,        # Seuil pauvreté national
        'LOWER_MIDDLE': 300_000,        # Classe moyenne inférieure
        'MIDDLE_CLASS': 500_000,        # Classe moyenne
        'UPPER_MIDDLE': 1_000_000,      # Classe moyenne supérieure
    }
    
    # === PONDÉRATIONS DIMENSIONS ===
    DIMENSION_WEIGHTS = {
        'economic': 0.30,      # Économique (priorité gouvernementale)
        'social': 0.25,        # Social (éducation, santé, réseaux)
        'demographic': 0.20,   # Démographique (âge, genre, ménage)
        'geographic': 0.15,    # Géographique (accessibilité, isolement)
        'resilience': 0.10,    # Résilience (chocs, adaptation)
    }
    
    # === PROVINCES GABON AVEC PRIORITÉS ===
    PROVINCE_RISK_FACTORS = {
        'ESTUAIRE': {'base_score': 10, 'urban_density': 0.8},      # Libreville
        'HAUT_OGOOUE': {'base_score': 25, 'mining_economy': 0.7},  # Franceville
        'MOYEN_OGOOUE': {'base_score': 35, 'rural_isolation': 0.9}, # Lambaréné
        'NGOUNIER': {'base_score': 30, 'agricultural': 0.8},      # Mouila
        'NYANGA': {'base_score': 40, 'coastal_remote': 0.9},      # Tchibanga
        'OGOOUE_IVINDO': {'base_score': 45, 'forest_isolation': 1.0}, # Makokou
        'OGOOUE_LOLO': {'base_score': 35, 'logging_economy': 0.8}, # Koulamoutou
        'OGOOUE_MARITIME': {'base_score': 20, 'oil_economy': 0.6}, # Port-Gentil
        'WOLEU_NTEM': {'base_score': 30, 'border_region': 0.7},   # Oyem
    }

    def __init__(self):
        """Initialisation du moteur de scoring"""
        self.logger = logging.getLogger(self.__class__.__name__)
        self.logger.info("🇬🇦 Initialisation moteur scoring vulnérabilité Gabon")

    def calculate_vulnerability_assessment(self, person_data: Dict) -> VulnerabilityAssessment:
        """
        Calcul complet évaluation vulnérabilité
        
        Args:
            person_data: Données complètes de la personne
            
        Returns:
            VulnerabilityAssessment: Évaluation complète
        """
        try:
            # 1. Calcul scores par dimension
            dimension_scores = {
                'economic': self._calculate_economic_dimension(person_data),
                'social': self._calculate_social_dimension(person_data),
                'demographic': self._calculate_demographic_dimension(person_data),
                'geographic': self._calculate_geographic_dimension(person_data),
                'resilience': self._calculate_resilience_dimension(person_data),
            }
            
            # 2. Score global pondéré
            global_score = self._calculate_weighted_global_score(dimension_scores)
            
            # 3. Niveau vulnérabilité
            vulnerability_level = self._determine_vulnerability_level(global_score)
            
            # 4. Éligibilité programmes sociaux
            programs_eligibility = self._calculate_programs_eligibility(
                dimension_scores, global_score
            )
            
            # 5. Zone priorité géographique
            geographic_priority = self._determine_geographic_priority(person_data)
            
            # 6. Interventions prioritaires
            priority_interventions = self._identify_priority_interventions(dimension_scores)
            
            # 7. Score confiance
            confidence_score = self._calculate_confidence_score(person_data)
            
            assessment = VulnerabilityAssessment(
                global_score=round(global_score, 2),
                vulnerability_level=vulnerability_level,
                dimension_scores=dimension_scores,
                priority_interventions=priority_interventions,
                social_programs_eligibility=programs_eligibility,
                geographic_priority_zone=geographic_priority,
                assessment_date=self._get_current_date(),
                confidence_score=confidence_score
            )
            
            self.logger.info(f"✅ Évaluation vulnérabilité calculée: {global_score:.2f}")
            return assessment
            
        except Exception as e:
            self.logger.error(f"❌ Erreur calcul vulnérabilité: {e}")
            raise

    def _calculate_economic_dimension(self, data: Dict) -> DimensionScore:
        """
        DIMENSION ÉCONOMIQUE (30% du score)
        Indicateurs: revenus, emploi, logement, patrimoine
        """
        score = 0.0
        factors = []
        risks = []
        recommendations = []
        
        # 1. REVENUS MENSUELS (50% dimension économique)
        monthly_income = data.get('monthly_income', 0)
        
        if monthly_income <= self.ECONOMIC_THRESHOLDS['EXTREME_POVERTY']:
            score += 50
            factors.append("Pauvreté extrême (<75k FCFA/mois)")
            risks.append("Insécurité alimentaire critique")
            recommendations.append("Transferts monétaires d'urgence")
        elif monthly_income <= self.ECONOMIC_THRESHOLDS['POVERTY_LINE']:
            score += 35
            factors.append("Sous seuil pauvreté (<150k FCFA/mois)")
            risks.append("Vulnérabilité aux chocs économiques")
            recommendations.append("Programme appui moyens subsistance")
        elif monthly_income <= self.ECONOMIC_THRESHOLDS['LOWER_MIDDLE']:
            score += 20
            factors.append("Revenus faibles (150-300k FCFA/mois)")
            risks.append("Précarité économique")
            recommendations.append("Formation professionnelle")
        
        # 2. STATUT EMPLOI (25% dimension économique)
        occupation = data.get('occupation', '').upper()
        
        if occupation in ['UNEMPLOYED', 'CHOMEUR']:
            score += 25
            factors.append("Chômage")
            risks.append("Exclusion sociale")
            recommendations.append("Programmes insertion professionnelle")
        elif occupation in ['INFORMAL', 'PETIT_COMMERCE']:
            score += 20
            factors.append("Emploi informel précaire")
            risks.append("Revenus irréguliers")
            recommendations.append("Formalisation activités économiques")
        elif occupation in ['FARMER', 'AGRICULTEUR', 'PECHEUR']:
            score += 15
            factors.append("Agriculture/pêche traditionnelle")
            risks.append("Dépendance climat/saisons")
            recommendations.append("Diversification moyens subsistance")
        
        # 3. TYPE LOGEMENT (15% dimension économique)
        housing_type = data.get('housing_type', '').upper()
        
        if housing_type in ['PRECARIOUS', 'BIDONVILLE', 'CASE_TRADITIONNELLE']:
            score += 15
            factors.append("Logement précaire")
            risks.append("Conditions vie insalubres")
            recommendations.append("Programme amélioration habitat")
        elif housing_type in ['RENTAL', 'LOCATION']:
            score += 8
            factors.append("Logement location")
            risks.append("Instabilité résidentielle")
        
        # 4. ACCÈS SERVICES FINANCIERS (10% dimension économique)
        has_bank_account = data.get('has_bank_account', False)
        if not has_bank_account:
            score += 10
            factors.append("Exclusion financière")
            risks.append("Difficultés épargne/crédit")
            recommendations.append("Inclusion financière digitale")
        
        return DimensionScore(
            dimension="economic",
            score=min(score, 100.0),
            weight=self.DIMENSION_WEIGHTS['economic'],
            contributing_factors=factors,
            risk_indicators=risks,
            recommendations=recommendations
        )

    def _calculate_social_dimension(self, data: Dict) -> DimensionScore:
        """
        DIMENSION SOCIALE (25% du score)
        Indicateurs: éducation, santé, réseaux sociaux, inclusion
        """
        score = 0.0
        factors = []
        risks = []
        recommendations = []
        
        # 1. NIVEAU ÉDUCATION (40% dimension sociale)
        education_level = data.get('education_level', '').upper()
        
        if education_level in ['NONE', 'AUCUN', 'ILLITERATE']:
            score += 40
            factors.append("Aucune éducation formelle")
            risks.append("Exclusion numérique et sociale")
            recommendations.append("Alphabétisation adultes")
        elif education_level in ['PRIMARY', 'PRIMAIRE']:
            score += 25
            factors.append("Éducation primaire seulement")
            risks.append("Opportunités emploi limitées")
            recommendations.append("Formation professionnelle adaptée")
        elif education_level in ['SECONDARY', 'SECONDAIRE']:
            score += 10
            factors.append("Éducation secondaire")
            recommendations.append("Formation continue")
        
        # 2. ACCÈS SOINS SANTÉ (30% dimension sociale)
        health_insurance = data.get('has_health_insurance', False)
        distance_health_center = data.get('distance_health_center_km', 50)
        
        if not health_insurance:
            score += 20
            factors.append("Pas d'assurance santé")
            risks.append("Barrières financières soins")
            recommendations.append("Couverture santé universelle")
        
        if distance_health_center > 30:
            score += 15
            factors.append(f"Centre santé éloigné ({distance_health_center}km)")
            risks.append("Accès difficile soins urgents")
            recommendations.append("Unités mobiles santé")
        elif distance_health_center > 15:
            score += 8
            factors.append("Accès santé limité")
            recommendations.append("Amélioration transport santé")
        
        # 3. RÉSEAUX SOCIAUX (20% dimension sociale)
        social_support = data.get('social_support_network', 'WEAK').upper()
        
        if social_support in ['NONE', 'AUCUN']:
            score += 20
            factors.append("Isolation sociale")
            risks.append("Vulnérabilité psychosociale")
            recommendations.append("Groupes entraide communautaire")
        elif social_support in ['WEAK', 'FAIBLE']:
            score += 12
            factors.append("Réseaux sociaux faibles")
            risks.append("Support limité en cas crise")
            recommendations.append("Renforcement liens communautaires")
        
        # 4. HANDICAP/VULNÉRABILITÉS SPÉCIALES (10% dimension sociale)
        has_disability = data.get('has_disability', False)
        if has_disability:
            score += 10
            factors.append("Handicap/vulnérabilité spéciale")
            risks.append("Discrimination et exclusion")
            recommendations.append("Programmes inclusion handicap")
        
        return DimensionScore(
            dimension="social",
            score=min(score, 100.0),
            weight=self.DIMENSION_WEIGHTS['social'],
            contributing_factors=factors,
            risk_indicators=risks,
            recommendations=recommendations
        )

    def _calculate_demographic_dimension(self, data: Dict) -> DimensionScore:
        """
        DIMENSION DÉMOGRAPHIQUE (20% du score)
        Indicateurs: âge, genre, structure ménage, dépendance
        """
        score = 0.0
        factors = []
        risks = []
        recommendations = []
        
        # 1. ÂGE VULNÉRABLE (30% dimension démographique)
        age = data.get('age', 30)
        
        if age < 5:
            score += 25
            factors.append("Enfant petite enfance (<5 ans)")
            risks.append("Malnutrition et mortalité infantile")
            recommendations.append("Programmes nutrition mère-enfant")
        elif age < 18:
            score += 15
            factors.append("Enfant/adolescent (<18 ans)")
            risks.append("Déscolarisation et travail précoce")
            recommendations.append("Protection enfance et scolarisation")
        elif age > 65:
            score += 20
            factors.append("Personne âgée (>65 ans)")
            risks.append("Isolement et soins inadéquats")
            recommendations.append("Programmes soins personnes âgées")
        
        # 2. GENRE ET RESPONSABILITÉS (25% dimension démographique)
        gender = data.get('gender', '').upper()
        is_household_head = data.get('is_household_head', False)
        marital_status = data.get('marital_status', '').upper()
        
        if gender == 'F' and is_household_head:
            score += 20
            factors.append("Femme chef de ménage")
            risks.append("Charge familiale et discrimination")
            recommendations.append("Appui femmes chefs de ménage")
        
        if marital_status in ['WIDOW', 'VEUVE', 'DIVORCED', 'DIVORCEE']:
            score += 15
            factors.append("Veuvage/divorce")
            risks.append("Perte support économique")
            recommendations.append("Aide sociale spécialisée")
        
        # 3. STRUCTURE MÉNAGE (25% dimension démographique)
        household_size = data.get('household_size', 4)
        dependents_count = data.get('dependents_count', 0)
        
        if household_size > 10:
            score += 15
            factors.append(f"Ménage très étendu ({household_size} membres)")
            risks.append("Ressources diluées")
            recommendations.append("Appui ménages étendus")
        elif household_size > 7:
            score += 8
            factors.append("Ménage étendu")
            recommendations.append("Soutien économique ciblé")
        
        # Ratio de dépendance
        if household_size > 0:
            dependency_ratio = dependents_count / household_size
            if dependency_ratio > 0.6:
                score += 12
                factors.append("Ratio dépendance élevé")
                risks.append("Charge économique excessive")
                recommendations.append("Transferts ciblés dépendants")
        
        # 4. GROSSESSE/ALLAITEMENT (20% dimension démographique)
        is_pregnant = data.get('is_pregnant', False)
        is_breastfeeding = data.get('is_breastfeeding', False)
        
        if is_pregnant or is_breastfeeding:
            score += 12
            factors.append("Grossesse/allaitement")
            risks.append("Besoins nutritionnels accrus")
            recommendations.append("Programmes santé maternelle")
        
        return DimensionScore(
            dimension="demographic",
            score=min(score, 100.0),
            weight=self.DIMENSION_WEIGHTS['demographic'],
            contributing_factors=factors,
            risk_indicators=risks,
            recommendations=recommendations
        )

    def _calculate_geographic_dimension(self, data: Dict) -> DimensionScore:
        """
        DIMENSION GÉOGRAPHIQUE (15% du score)
        Indicateurs: localisation, accessibilité, infrastructures
        """
        score = 0.0
        factors = []
        risks = []
        recommendations = []
        
        # 1. PROVINCE ET ÉLOIGNEMENT (40% dimension géographique)
        province = data.get('province', 'ESTUAIRE').upper()
        province_factors = self.PROVINCE_RISK_FACTORS.get(province, {'base_score': 25})
        
        base_score = province_factors['base_score']
        score += base_score
        
        if base_score >= 40:
            factors.append(f"Province isolée ({province})")
            risks.append("Accès limité services publics")
            recommendations.append("Programmes développement rural")
        elif base_score >= 25:
            factors.append(f"Province périphérique ({province})")
            recommendations.append("Amélioration infrastructures")
        
        # 2. TYPE ZONE (30% dimension géographique)
        zone_type = data.get('zone_type', 'RURAL').upper()
        
        if zone_type in ['RURAL_REMOTE', 'FORET_ISOLEE']:
            score += 30
            factors.append("Zone rurale très isolée")
            risks.append("Exclusion numérique et physique")
            recommendations.append("Infrastructures connectivité")
        elif zone_type in ['RURAL', 'RURAL_ACCESSIBLE']:
            score += 20
            factors.append("Zone rurale")
            risks.append("Services limités")
            recommendations.append("Services publics mobiles")
        elif zone_type in ['URBAN_PERIPHERY', 'PERIURBAIN']:
            score += 10
            factors.append("Périphérie urbaine")
            recommendations.append("Extension services urbains")
        
        # 3. ACCESSIBILITÉ TRANSPORT (20% dimension géographique)
        road_access = data.get('road_access_type', 'DIRT').upper()
        
        if road_access in ['FOOTPATH', 'SENTIER', 'NONE']:
            score += 20
            factors.append("Pas d'accès routier")
            risks.append("Isolement total en saison pluies")
            recommendations.append("Infrastructures transport de base")
        elif road_access in ['DIRT', 'TERRE_BATTUE']:
            score += 12
            factors.append("Accès routier précaire")
            risks.append("Coupure saisonnière")
            recommendations.append("Amélioration routes rurales")
        elif road_access in ['GRAVEL', 'LATERITE']:
            score += 6
            factors.append("Route latérite")
            recommendations.append("Bitumage prioritaire")
        
        # 4. SERVICES PROXIMITÉ (10% dimension géographique)
        distance_services = data.get('distance_nearest_town_km', 50)
        
        if distance_services > 100:
            score += 10
            factors.append("Services très éloignés (>100km)")
            risks.append("Urgences médicales compromises")
            recommendations.append("Centres services décentralisés")
        elif distance_services > 50:
            score += 6
            factors.append("Services éloignés")
            recommendations.append("Transport public amélioré")
        
        return DimensionScore(
            dimension="geographic",
            score=min(score, 100.0),
            weight=self.DIMENSION_WEIGHTS['geographic'],
            contributing_factors=factors,
            risk_indicators=risks,
            recommendations=recommendations
        )

    def _calculate_resilience_dimension(self, data: Dict) -> DimensionScore:
        """
        DIMENSION RÉSILIENCE (10% du score)
        Indicateurs: exposition chocs, mécanismes adaptation, récupération
        """
        score = 0.0
        factors = []
        risks = []
        recommendations = []
        
        # 1. EXPOSITION AUX CHOCS (40% dimension résilience)
        climate_exposure = data.get('climate_shock_exposure', 'MEDIUM').upper()
        economic_shocks = data.get('economic_shock_history', False)
        
        if climate_exposure in ['HIGH', 'ELEVE']:
            score += 25
            factors.append("Forte exposition chocs climatiques")
            risks.append("Pertes agricoles récurrentes")
            recommendations.append("Adaptation changement climatique")
        elif climate_exposure in ['MEDIUM', 'MOYEN']:
            score += 15
            factors.append("Exposition modérée aux chocs")
            recommendations.append("Mécanismes prévention")
        
        if economic_shocks:
            score += 15
            factors.append("Historique chocs économiques")
            risks.append("Vulnérabilité cycles économiques")
            recommendations.append("Diversification revenus")
        
        # 2. MÉCANISMES ADAPTATION (35% dimension résilience)
        savings = data.get('has_savings', False)
        diversified_income = data.get('diversified_income_sources', False)
        
        if not savings:
            score += 20
            factors.append("Aucune épargne")
            risks.append("Pas de coussin sécurité")
            recommendations.append("Programmes épargne communautaire")
        
        if not diversified_income:
            score += 15
            factors.append("Revenus non diversifiés")
            risks.append("Dépendance source unique")
            recommendations.append("Développement activités secondaires")
        
        # 3. CAPACITÉ RÉCUPÉRATION (25% dimension résilience)
        recovery_time_last_shock = data.get('recovery_time_months', 12)
        
        if recovery_time_last_shock > 24:
            score += 15
            factors.append("Récupération très lente (>2 ans)")
            risks.append("Spirale appauvrissement")
            recommendations.append("Aide relèvement d'urgence")
        elif recovery_time_last_shock > 12:
            score += 10
            factors.append("Récupération lente (>1 an)")
            recommendations.append("Appui reconstruction")
        
        return DimensionScore(
            dimension="resilience",
            score=min(score, 100.0),
            weight=self.DIMENSION_WEIGHTS['resilience'],
            contributing_factors=factors,
            risk_indicators=risks,
            recommendations=recommendations
        )

    def _calculate_weighted_global_score(self, dimension_scores: Dict[str, DimensionScore]) -> float:
        """Calcul score global pondéré"""
        weighted_sum = sum(
            score.score * score.weight
            for score in dimension_scores.values()
        )
        return round(weighted_sum, 2)

    def _determine_vulnerability_level(self, global_score: float) -> VulnerabilityLevel:
        """Détermine niveau vulnérabilité selon seuils gouvernementaux"""
        if global_score >= 75:
            return VulnerabilityLevel.CRITICAL
        elif global_score >= 50:
            return VulnerabilityLevel.HIGH
        elif global_score >= 25:
            return VulnerabilityLevel.MODERATE
        else:
            return VulnerabilityLevel.LOW

    def _calculate_programs_eligibility(self, dimension_scores: Dict[str, DimensionScore], 
                                      global_score: float) -> Dict[str, float]:
        """
        Calcul éligibilité programmes sociaux selon scores dimensions
        """
        eligibility = {}
        
        # Programme Transferts Monétaires
        economic_score = dimension_scores['economic'].score
        if economic_score >= 35:
            eligibility['transferts_monetaires'] = min(economic_score * 1.2, 100.0)
        
        # Programme Nutrition Maternelle
        demographic_score = dimension_scores['demographic'].score
        if demographic_score >= 25:
            eligibility['nutrition_maternelle'] = min(demographic_score * 1.1, 100.0)
        
        # Programme Développement Rural
        geographic_score = dimension_scores['geographic'].score
        if geographic_score >= 30:
            eligibility['developpement_rural'] = min(geographic_score * 1.15, 100.0)
        
        # Programme Formation Professionnelle
        social_score = dimension_scores['social'].score
        if social_score >= 20:
            eligibility['formation_professionnelle'] = min(social_score * 1.05, 100.0)
        
        # Programme Aide d'Urgence
        if global_score >= 70:
            eligibility['aide_urgence'] = min(global_score * 1.1, 100.0)
        
        return eligibility

    def _determine_geographic_priority(self, data: Dict) -> str:
        """Détermine zone priorité géographique"""
        province = data.get('province', 'ESTUAIRE').upper()
        zone_type = data.get('zone_type', 'RURAL').upper()
        
        province_factors = self.PROVINCE_RISK_FACTORS.get(province, {'base_score': 25})
        
        if province_factors['base_score'] >= 40 and 'REMOTE' in zone_type:
            return 'CRITICAL_PRIORITY'
        elif province_factors['base_score'] >= 30:
            return 'HIGH_PRIORITY'
        elif province_factors['base_score'] >= 20:
            return 'MEDIUM_PRIORITY'
        else:
            return 'LOW_PRIORITY'

    def _identify_priority_interventions(self, dimension_scores: Dict[str, DimensionScore]) -> List[str]:
        """Identifie interventions prioritaires selon scores élevés"""
        interventions = []
        
        # Trier dimensions par score décroissant
        sorted_dimensions = sorted(
            dimension_scores.items(),
            key=lambda x: x[1].score,
            reverse=True
        )
        
        for dimension_name, dimension_score in sorted_dimensions:
            if dimension_score.score >= 50:
                interventions.extend(dimension_score.recommendations[:2])  # Top 2 recommandations
                
        return interventions[:5]  # Max 5 interventions prioritaires

    def _calculate_confidence_score(self, data: Dict) -> float:
        """
        Calcul score confiance basé sur complétude données
        """
        required_fields = [
            'monthly_income', 'occupation', 'education_level', 'age', 'gender',
            'household_size', 'province', 'zone_type', 'housing_type'
        ]
        
        present_fields = sum(1 for field in required_fields if data.get(field) is not None)
        completeness = present_fields / len(required_fields)
        
        # Score confiance: 60% complétude + 40% cohérence
        coherence_score = self._check_data_coherence(data)
        confidence = (completeness * 0.6) + (coherence_score * 0.4)
        
        return round(confidence * 100, 1)

    def _check_data_coherence(self, data: Dict) -> float:
        """Vérifie cohérence des données"""
        coherence_score = 1.0
        
        # Cohérence revenu/emploi
        income = data.get('monthly_income', 0)
        occupation = data.get('occupation', '').upper()
        
        if occupation == 'UNEMPLOYED' and income > 50000:
            coherence_score -= 0.2
        
        # Cohérence âge/éducation
        age = data.get('age', 30)
        education = data.get('education_level', '').upper()
        
        if age < 10 and education in ['SECONDARY', 'TERTIARY']:
            coherence_score -= 0.3
            
        return max(coherence_score, 0.0)

    def _get_current_date(self) -> str:
        """Retourne date actuelle formatée"""
        from datetime import datetime
        return datetime.now().strftime("%Y-%m-%d")

# === EXEMPLE D'UTILISATION ===
if __name__ == "__main__":
    # Données test personne vulnérable
    test_person = {
        'age': 28,
        'gender': 'F',
        'is_household_head': True,
        'marital_status': 'WIDOW',
        'monthly_income': 60000,  # Sous seuil pauvreté extrême
        'occupation': 'FARMER',
        'education_level': 'PRIMARY',
        'household_size': 8,
        'dependents_count': 5,
        'has_health_insurance': False,
        'distance_health_center_km': 45,
        'has_bank_account': False,
        'housing_type': 'CASE_TRADITIONNELLE',
        'province': 'OGOOUE_IVINDO',  # Province isolée forêt
        'zone_type': 'RURAL_REMOTE',
        'road_access_type': 'DIRT',
        'distance_nearest_town_km': 80,
        'climate_shock_exposure': 'HIGH',
        'has_savings': False,
        'diversified_income_sources': False,
        'recovery_time_months': 30,
        'social_support_network': 'WEAK',
        'is_pregnant': True,
    }
    
    # Initialisation moteur
    scoring_engine = GabonVulnerabilityScoringEngine()
    
    # Calcul évaluation complète
    assessment = scoring_engine.calculate_vulnerability_assessment(test_person)
    
    # Affichage résultats
    print("🇬🇦 ÉVALUATION VULNÉRABILITÉ RSU GABON")
    print("=" * 50)
    print(f"Score Global: {assessment.global_score}/100")
    print(f"Niveau: {assessment.vulnerability_level.value}")
    print(f"Zone Priorité: {assessment.geographic_priority_zone}")
    print(f"Confiance: {assessment.confidence_score}%")
    print()
    
    print("📊 SCORES PAR DIMENSION:")
    for dim_name, dim_score in assessment.dimension_scores.items():
        print(f"  {dim_name.upper()}: {dim_score.score:.1f}/100 (poids: {dim_score.weight:.0%})")
    print()
    
    print("🎯 INTERVENTIONS PRIORITAIRES:")
    for intervention in assessment.priority_interventions:
        print(f"  • {intervention}")
    print()
    
    print("📋 ÉLIGIBILITÉ PROGRAMMES SOCIAUX:")
    for program, eligibility in assessment.social_programs_eligibility.items():
        print(f"  • {program}: {eligibility:.1f}% éligible")
    print()
    
    print("⚠️ FACTEURS DE RISQUE IDENTIFIÉS:")
    for dim_name, dim_score in assessment.dimension_scores.items():
        if dim_score.score >= 30:  # Dimensions à risque
            print(f"  {dim_name.upper()}:")
            for factor in dim_score.contributing_factors:
                print(f"    - {factor}")
    print()
    
    print("💡 RECOMMANDATIONS:")
    for dim_name, dim_score in assessment.dimension_scores.items():
        if dim_score.recommendations:
            print(f"  {dim_name.upper()}:")
            for rec in dim_score.recommendations[:2]:  # Top 2 recommandations
                print(f"    → {rec}")
    
    print("\n✅ Évaluation terminée - Conforme standards gouvernementaux Gabon")